diff -Naur origsrc/include/lib.h src/include/lib.h
--- origsrc/include/lib.h	2005-06-01 14:30:59.000000000 +0000
+++ src/include/lib.h	2009-08-29 19:10:33.000000000 +0000
@@ -25,6 +25,7 @@
 
 #define MM                 PM_PROC_NR
 #define FS                 FS_PROC_NR
+#define SS                 SS_PROC_NR
 
 _PROTOTYPE( int __execve, (const char *_path, char *const _argv[], 
 			char *const _envp[], int _nargs, int _nenvps)	);
diff -Naur origsrc/include/lib.notinuse.h src/include/lib.notinuse.h
--- origsrc/include/lib.notinuse.h	1970-01-01 00:00:00.000000000 +0000
+++ src/include/lib.notinuse.h	2009-08-29 19:10:33.000000000 +0000
@@ -0,0 +1,37 @@
+/* The <lib.h> header is the master header used by the library.
+ * All the C files in the lib subdirectories include it.
+ */
+
+#ifndef _LIB_H
+#define _LIB_H
+
+/* First come the defines. */
+#define _POSIX_SOURCE      1	/* tell headers to include POSIX stuff */
+#define _MINIX             1	/* tell headers to include MINIX stuff */
+
+/* The following are so basic, all the lib files get them automatically. */
+#include <minix/config.h>	/* must be first */
+#include <sys/types.h>
+#include <limits.h>
+#include <errno.h>
+#include <ansi.h>
+
+#include <minix/const.h>
+#include <minix/com.h>
+#include <minix/type.h>
+#include <minix/callnr.h>
+
+#include <minix/ipc.h>
+
+#define MM                 PM_PROC_NR
+#define FS                 FS_PROC_NR
+#define SS               SYNC_PROC_NR
+
+_PROTOTYPE( int __execve, (const char *_path, char *const _argv[], 
+			char *const _envp[], int _nargs, int _nenvps)	);
+_PROTOTYPE( int _syscall, (int _who, int _syscallnr, message *_msgptr)	);
+_PROTOTYPE( void _loadname, (const char *_name, message *_msgptr)	);
+_PROTOTYPE( int _len, (const char *_s)					);
+_PROTOTYPE( void _begsig, (int _dummy)					);
+
+#endif /* _LIB_H */
diff -Naur origsrc/include/minix/callnr.h src/include/minix/callnr.h
--- origsrc/include/minix/callnr.h	2005-08-04 19:23:02.000000000 +0000
+++ src/include/minix/callnr.h	2009-08-31 22:25:08.000000000 +0000
@@ -1,4 +1,4 @@
-#define NCALLS		  91	/* number of system calls allowed */
+#define NCALLS		  97	/* number of system calls allowed */
 
 #define EXIT		   1 
 #define FORK		   2 
@@ -79,3 +79,12 @@
 #define GETPRIORITY       88	/* to PM */
 #define SETPRIORITY       89	/* to PM */
 #define GETTIMEOFDAY      90	/* to PM */
+
+/* concurrency API spesific calls */
+#define MUTEXCREATE       91	/* to SS */
+#define MUTEXDESROY       92	/* to SS */
+#define MUTEXLOCK         93	/* to SS */
+#define MUTEXUNLOCK       94	/* to SS */
+#define CONDWAIT          95    /* to SS */
+#define CONDSIGNAL        96    /* to SS */
+
diff -Naur origsrc/include/minix/com.h src/include/minix/com.h
--- origsrc/include/minix/com.h	2005-09-16 14:23:14.000000000 +0000
+++ src/include/minix/com.h	2009-08-31 03:40:54.000000000 +0000
@@ -38,7 +38,9 @@
 #define LOG_PROC_NR	  4	/* log device driver */
 #define TTY_PROC_NR	  5	/* terminal (TTY) driver */
 #define DRVR_PROC_NR      6	/* device driver for boot medium */
-#define INIT_PROC_NR	  7    	/* init -- goes multiuser */
+#define SS_PROC_NR	  7    	/* sync server (mutexes, condvars, and 'threads') */
+#define INIT_PROC_NR	  8    	/* init -- goes multiuser */
+
 
 /* Number of processes contained in the system image. */
 #define NR_BOOT_PROCS 	(NR_TASKS + INIT_PROC_NR + 1)
diff -Naur origsrc/servers/Makefile src/servers/Makefile
--- origsrc/servers/Makefile	2005-08-29 20:00:39.000000000 +0000
+++ src/servers/Makefile	2009-08-29 19:10:33.000000000 +0000
@@ -20,12 +20,15 @@
 	cd ./rs && $(MAKE) $@
 	cd ./is && $(MAKE) $@
 	cd ./init && $(MAKE) $@
+	cd ./ss && $(MAKE) $@
 	cd ./inet && $(MAKE) $@
 
 image:
 	cd ./pm && $(MAKE) EXTRA_OPTS=$(EXTRA_OPTS) build
 	cd ./fs && $(MAKE) EXTRA_OPTS=$(EXTRA_OPTS) build
 	cd ./rs && $(MAKE) EXTRA_OPTS=$(EXTRA_OPTS) build
+	cd ./ss && $(MAKE) EXTRA_OPTS=$(EXTRA_OPTS) build
 	cd ./init && $(MAKE) EXTRA_OPTS=$(EXTRA_OPTS) build
+	
 
 
diff -Naur origsrc/servers/fs/table.c src/servers/fs/table.c
--- origsrc/servers/fs/table.c	2005-08-04 19:23:02.000000000 +0000
+++ src/servers/fs/table.c	2009-08-31 22:26:06.000000000 +0000
@@ -108,6 +108,13 @@
 	no_sys,		/* 88 = getpriority */
 	no_sys,		/* 89 = setpriority */
 	no_sys,		/* 90 = gettimeofday */
+	
+	no_sys,    /* 91 = mutexcreate */
+	no_sys,   /* 92 = mutexdestroy */
+	no_sys,  /* 93 = mutexlock */
+	no_sys,    /* 94 = mutexunlock */
+	no_sys,       /* 95 = condwait */
+	no_sys,     /* 96 = condsignal */
 };
 /* This should not fail with "array size is negative": */
 extern int dummy[sizeof(call_vec) == NCALLS * sizeof(call_vec[0]) ? 1 : -1];
diff -Naur origsrc/servers/pm/forkexit.c src/servers/pm/forkexit.c
--- origsrc/servers/pm/forkexit.c	2005-09-01 10:16:07.000000000 +0000
+++ src/servers/pm/forkexit.c	2009-08-31 04:56:17.000000000 +0000
@@ -147,7 +147,8 @@
   p_mp->mp_child_utime += t[0] + rmp->mp_child_utime;	/* add user time */
   p_mp->mp_child_stime += t[1] + rmp->mp_child_stime;	/* add system time */
 
-  /* Tell the kernel and FS that the process is no longer runnable. */
+  /* Tell the kernel, FS, and SS that the process is no longer runnable. */
+  tell_ss(EXIT, proc_nr, 0, 0);  /* sync server can free lock held by proc_nr */
   tell_fs(EXIT, proc_nr, 0, 0);  /* file system can free the proc slot */
   sys_exit(proc_nr);
 
diff -Naur origsrc/servers/pm/main.c src/servers/pm/main.c
--- origsrc/servers/pm/main.c	2005-09-11 16:45:46.000000000 +0000
+++ src/servers/pm/main.c	2009-08-29 19:10:33.000000000 +0000
@@ -202,7 +202,7 @@
   for (ip = &image[0]; ip < &image[NR_BOOT_PROCS]; ip++) {		
   	if (ip->proc_nr >= 0) {			/* task have negative nrs */
   		procs_in_use += 1;		/* found user process */
-
+        
 		/* Set process details found in the image table. */
 		rmp = &mproc[ip->proc_nr];	
   		strncpy(rmp->mp_name, ip->proc_name, PROC_NAME_LEN); 
diff -Naur origsrc/servers/pm/param.h src/servers/pm/param.h
--- origsrc/servers/pm/param.h	2005-08-05 12:44:06.000000000 +0000
+++ src/servers/pm/param.h	2009-08-30 19:47:23.000000000 +0000
@@ -52,6 +52,11 @@
 #define reply_t4 	m4_l4
 #define reply_t5 	m4_l5
 
+/* The following names are used to inform the SS about certain events. */
+#define tell_ss_arg1    m1_i1
+#define tell_ss_arg2    m1_i2
+#define tell_ss_arg3    m1_i3
+
 /* The following names are used to inform the FS about certain events. */
 #define tell_fs_arg1    m1_i1
 #define tell_fs_arg2    m1_i2
diff -Naur origsrc/servers/pm/proto.h src/servers/pm/proto.h
--- origsrc/servers/pm/proto.h	2005-08-25 12:05:09.000000000 +0000
+++ src/servers/pm/proto.h	2009-08-30 19:27:35.000000000 +0000
@@ -105,6 +105,7 @@
 _PROTOTYPE( int allowed, (char *name_buf, struct stat *s_buf, int mask)	);
 _PROTOTYPE( int no_sys, (void)						);
 _PROTOTYPE( void panic, (char *who, char *mess, int num)		);
+_PROTOTYPE( void tell_ss, (int what, int p1, int p2, int p3)		);
 _PROTOTYPE( void tell_fs, (int what, int p1, int p2, int p3)		);
 _PROTOTYPE( int get_stack_ptr, (int proc_nr, vir_bytes *sp)		);
 _PROTOTYPE( int get_mem_map, (int proc_nr, struct mem_map *mem_map)	);
diff -Naur origsrc/servers/pm/table.c src/servers/pm/table.c
--- origsrc/servers/pm/table.c	2005-08-10 09:37:54.000000000 +0000
+++ src/servers/pm/table.c	2009-08-31 22:25:39.000000000 +0000
@@ -107,6 +107,13 @@
 	do_getsetpriority,	/* 88 = getpriority */
 	do_getsetpriority,	/* 89 = setpriority */
 	do_time,	/* 90 = gettimeofday */
+	
+	no_sys,    /* 91 = mutexcreate */
+	no_sys,   /* 92 = mutexdestroy */
+	no_sys,  /* 93 = mutexlock */
+	no_sys,    /* 94 = mutexunlock */
+	no_sys,       /* 95 = condwait */
+	no_sys,     /* 96 = condsignal */
 };
 /* This should not fail with "array size is negative": */
 extern int dummy[sizeof(call_vec) == NCALLS * sizeof(call_vec[0]) ? 1 : -1];
diff -Naur origsrc/servers/pm/utility.c src/servers/pm/utility.c
--- origsrc/servers/pm/utility.c	2005-09-11 16:45:46.000000000 +0000
+++ src/servers/pm/utility.c	2009-08-30 19:47:45.000000000 +0000
@@ -120,6 +120,23 @@
 }
 
 /*===========================================================================*
+ *				tell_ss					     *
+ *===========================================================================*/
+PUBLIC void tell_ss(what, p1, p2, p3)
+int what, p1, p2, p3;
+{
+/* This routine is only used by PM to inform SS of certain events:
+ *      tell_fs(EXIT, proc, 0, 0)
+ */
+  message m;
+
+  m.tell_ss_arg1 = p1;
+  m.tell_ss_arg2 = p2;
+  m.tell_ss_arg3 = p3;
+  _taskcall(SS_PROC_NR, what, &m);
+}
+
+/*===========================================================================*
  *				tell_fs					     *
  *===========================================================================*/
 PUBLIC void tell_fs(what, p1, p2, p3)
diff -Naur origsrc/servers/ss/.depend src/servers/ss/.depend
--- origsrc/servers/ss/.depend	1970-01-01 00:00:00.000000000 +0000
+++ src/servers/ss/.depend	2009-08-29 19:10:33.000000000 +0000
@@ -0,0 +1,6 @@
+
+main.o:	/usr/include/ansi.h
+main.o:	/usr/include/stdio.h
+main.o:	/usr/include/sys/dir.h
+main.o:	/usr/include/sys/types.h
+main.o:	main.c
diff -Naur origsrc/servers/ss/Makefile src/servers/ss/Makefile
--- origsrc/servers/ss/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ src/servers/ss/Makefile	2009-08-30 20:43:57.000000000 +0000
@@ -0,0 +1,38 @@
+# Makefile for (sync server)
+SERVER = ss
+
+# directories
+u = /usr
+i = $u/include
+s = $i/sys
+h = $i/minix
+k = $u/src/kernel
+
+# programs, flags, etc.
+CC =	exec cc
+CFLAGS = -I$i
+LDFLAGS = -i
+
+OBJ = 	main.o table.o utility.o mutexops.o condvars.o misc.o
+
+# build local binary
+all build:	$(SERVER)
+$(SERVER):	$(OBJ)
+	$(CC) -o $@ $(LDFLAGS) $(OBJ) -lsys -lsysutil -ltimers
+	install -S 1024w $@
+
+# install with other servers
+install:	/usr/sbin/$(SERVER)
+/usr/sbin/$(SERVER):	$(SERVER)
+	install -o root -cs $? $@
+
+# clean up local files
+clean:
+	rm -f $(SERVER) *.o *.bak 
+
+depend: 
+	/usr/bin/mkdep "$(CC) -E $(CPPFLAGS)" *.c > .depend
+
+# Include generated dependencies.
+include .depend
+
diff -Naur origsrc/servers/ss/condvars.c src/servers/ss/condvars.c
--- origsrc/servers/ss/condvars.c	1970-01-01 00:00:00.000000000 +0000
+++ src/servers/ss/condvars.c	2009-08-31 22:35:48.000000000 +0000
@@ -0,0 +1,96 @@
+#include "ss.h"
+#include "param.h"
+
+/*===========================================================================*
+ *                                do_condwait                                *
+ *===========================================================================*/
+PUBLIC int do_condwait(void) {
+	mutex_t *mutex;
+	condvar_t *condvar;
+	
+	if (VERBOSE > 1) printf("SS: %s: do_condwait() syscall by %d, mutex: %d, condvar: %d\n", 
+			__FILE__, who, m_in.mutex_desc, m_in.cond_id);
+	
+	
+	/* Check validity of given mutex descriptor. */
+	mutex = get_mutex(m_in.mutex_desc);
+	if (mutex == NULL) {
+		return EINVAL;
+	}
+	
+	/* Check validity of requested mutex. */
+	if (mutex->state == MUTEX_UNUSED || mutex->state == MUTEX_UNLOCKED) {
+		return EINVAL;
+	} else if (mutex->state == MUTEX_LOCKED && mutex->holder != who) {
+		return EINVAL;
+	}
+	assert(mutex->state == MUTEX_LOCKED);
+	
+	/* Check validity of given condition variable descriptor. */
+	condvar = get_condvar(mutex, m_in.cond_id);
+	if (condvar == NULL) {
+		return EDOM;
+	} else {
+		/* The mutex and condition variable are valid. */
+		wait_t *new = (wait_t *) malloc(sizeof(wait_t));
+		if (new == NULL)
+			return EINVAL;  /* TODO: correct error? */
+		
+		/* Enqueue caller to the mutex' condition variable's wait queue. */
+		new->dest  = who;     /* save origin of request */
+		new->value = EINVAL;  /* changed to OK once lock is reacquired */
+		new->next  = NULL;
+		
+		wait_enqueue(&condvar->wait_queue, new);
+	}
+	
+	/* Unlock the mutex. */
+	mutex_unlock(m_in.mutex_desc);
+	
+	/* do not send out reply yet. block lock requester until resource becomes available */      
+	return ON_HOLD;
+}
+
+/*===========================================================================*
+ *                              do_condsignal                                *
+ *===========================================================================*/
+PUBLIC int do_condsignal(void) {
+	mutex_t *mutex;
+	condvar_t *condvar;
+	
+	if (VERBOSE > 1) printf("SS: %s: do_condsignal() syscall by %d, mutex: %d, condvar: %d\n", 
+			__FILE__, who, m_in.mutex_desc, m_in.cond_id);
+	
+	
+	/* Check validity of given mutex descriptor. */
+	mutex = get_mutex(m_in.mutex_desc);
+	if (mutex == NULL) {
+		return EINVAL;
+	}
+	
+	/* Check validity of requested mutex. */
+	if (mutex->state == MUTEX_UNUSED || mutex->state == MUTEX_UNLOCKED) {
+		return EINVAL;
+	} else if (mutex->state == MUTEX_LOCKED && mutex->holder != who) {
+		return EINVAL;
+	}
+	assert(mutex->state == MUTEX_LOCKED);
+	
+	/* Check validity of given condition variable descriptor. */
+	condvar = get_condvar(mutex, m_in.cond_id);
+	if (condvar == NULL) {
+		return EDOM; /*TODO klopt dit wel ?*/
+	}
+	
+	/* The mutex and condition variable are valid.  Check if someone is
+	 * waiting for a signal, if yes, move him from the condvar queue to the
+	 * mutex queue.  It will unblock when the mutex is released. */
+	if (condvar->wait_queue != NULL) {
+		wait_t *new = wait_dequeue(&condvar->wait_queue);
+		wait_enqueue(&mutex->wait_queue, new);
+		if (VERBOSE > 1) printf("SS: %s: do_condsignal() moved a node from mutex' %d condvar %d to mutex %d\n",
+				__FILE__, m_in.mutex_desc, m_in.cond_id, m_in.mutex_desc);
+	}
+	
+	return OK;
+}
diff -Naur origsrc/servers/ss/const.h src/servers/ss/const.h
--- origsrc/servers/ss/const.h	1970-01-01 00:00:00.000000000 +0000
+++ src/servers/ss/const.h	2009-08-31 18:54:33.000000000 +0000
@@ -0,0 +1,25 @@
+/* Constants used by the Synchronisation Server. */
+#define VERBOSE         0       /* show messages during initialization? */
+#define OK              0       /* */
+#define NR_MUTEX        8       /* max number of mutexes the sync server can support */
+
+/* condition variable constants */
+#define MIN_CV          1       /* minimum value of a condition variable */
+#define MAX_CV          64      /* maximum value of a condition variable */
+#define NR_CONDVARS     64      /* number of condition variables */
+
+/* State constants*/
+#define MUTEX_UNUSED    0       /* mutex unused state */
+#define MUTEX_UNLOCKED  1       /* mutex used but unlocked state */
+#define MUTEX_LOCKED    2       /* mutex locked state */
+
+/*TODO remove. QUEUE indicators */
+#define LOCK_Q          0       /* queue to use is lock requests queue */
+#define COND_VAR_Q      1       /* queue to use is condition variables queue */
+#define REPLY_Q         2       /* queue to use is reply queue */
+/*TODO remove. */
+#define MAX_PENDING     1024    /* max number of pending lock opperations */
+
+/*this has to be last otherwise MUTEX_LOCKED is interpreted as string i.s.o. int*/
+#define ON_HOLD         -1024   /* used to signal on hold status */
+#define KILL_ME         -2048   /* default return value set on wait_t messages */
diff -Naur origsrc/servers/ss/glo.h src/servers/ss/glo.h
--- origsrc/servers/ss/glo.h	1970-01-01 00:00:00.000000000 +0000
+++ src/servers/ss/glo.h	2009-08-31 22:41:12.000000000 +0000
@@ -0,0 +1,24 @@
+/* EXTERN should be extern except in table.c */
+#ifdef _TABLE
+#undef EXTERN
+#define EXTERN
+#endif
+
+/* TODO (?) arrays for fast access, linked list for dynamic queue sizes. */
+
+/* UPDATE linked list implementation of wait queues. Nice because now memory 
+ * in charge of the maximum ammount the list can hold. (less arbitrary than 
+ * setting the number to 1024 (in const.h))
+ */
+
+/* Global variables. */
+EXTERN mutex_t mutexes[NR_MUTEX];
+EXTERN wait_t *reply_queue;
+
+/* The parameters of the call are kept here. */
+EXTERN message m_in;		/* the incoming message itself is kept here. */
+EXTERN message m_out;       /* the output message used for reply */
+EXTERN int who;			/* caller's proc number */
+EXTERN int call_nr;		/* system call number */
+
+extern _PROTOTYPE (int (*call_vec[]), (void) );	/* system call handlers */
diff -Naur origsrc/servers/ss/main.c src/servers/ss/main.c
--- origsrc/servers/ss/main.c	1970-01-01 00:00:00.000000000 +0000
+++ src/servers/ss/main.c	2009-08-31 22:30:18.000000000 +0000
@@ -0,0 +1,120 @@
+#include "ss.h"
+#include <signal.h>
+
+
+/* Declare some local functions. */
+FORWARD _PROTOTYPE(void get_work, (void)                    );
+FORWARD _PROTOTYPE(void reply, (int whom, int result)		);
+FORWARD _PROTOTYPE(void ss_init, (void)                     ); 
+
+
+/*===========================================================================*
+ *				main					     *
+ *===========================================================================*/
+PUBLIC int main(void) 
+{
+    sigset_t sigset;
+    int i, result;
+    
+	ss_init();  /* initialize synchronisation server's tables */
+	
+	/* Main loop that gets work, processes it, and sends replies. */
+	while (TRUE) {
+		get_work();  /* sets who and call_nr */
+		
+		if (call_nr == SYS_SIG) { 
+    		sigset = m_in.NOTIFY_ARG;
+    		/* if kernel shutting down */
+    		if (sigismember(&sigset, SIGKSTOP)) {
+                exit(0);  		/* never returns */
+    		}
+		}
+		
+		/* Call the internal function that does the work. */
+		if (call_nr < 0 || call_nr >= NCALLS) { 
+			result = ENOSYS;
+			/* printf("SS, warning illegal %d system call by %d\n", call_nr, who); */
+		} else {
+		    /* Do syscall and send reply message, unless it is ON_HOLD. */
+		    result = (*call_vec[call_nr])();
+    		
+    		/* Copy the results back to the user and send reply. */
+		    if (result != ON_HOLD) { 
+		        reply(who, result); 
+		    } else { 
+		        if (VERBOSE > 2) 
+		            printf("SS: %s: main(): got ON_HOLD request, so send notifation later!\n",
+		               __FILE__);
+    		}
+    		
+    		/* Send out all message in reply_queue (usually 1, could be all 
+    		 * in case of mutex_release_all() call) 
+    		 */
+    		while (reply_queue != NULL) {
+    			wait_t *new = wait_dequeue(&reply_queue);
+    			reply(new->dest, new->value);  /* TODO: check if still alive. Nope. */
+    			free(new);
+    			if (VERBOSE > 1) printf("SS: %s: main(): just freed a m_node!\n",
+    			    __FILE__);
+    		}
+		}
+	}
+	
+	return OK;
+}
+
+
+
+/*===========================================================================*
+ *				get_work                                     *
+ *===========================================================================*/
+PRIVATE void get_work(void)
+{
+    int status = 0;
+    status = receive(ANY, &m_in);   /* this blocks until message arrives */
+    if (OK != status)
+    /*TODO is something is horibly wrong? */
+        panic(__FILE__,"failed to receive message!", status);
+    who = m_in.m_source;        /* message arrived! set sender */
+    call_nr = m_in.m_type;       /* set function call number */
+}
+
+
+/*===========================================================================*
+ *				reply					     *
+ *===========================================================================*/
+PRIVATE void reply(who, result)
+int who;                           	/* destination */
+int result;                           	/* report result to replyee */
+{
+    int i, send_status;
+    m_out.m_type = result;  		/* build reply message */
+    send_status = send(who, &m_out);    /* send the message */
+    /* sending failed, did we miss a do_exit call by PM? exit! */
+    if (OK != send_status)
+        panic(__FILE__, "unable to send reply!", send_status);
+}
+
+
+/*===========================================================================*
+ *				ss_init					     *
+ *===========================================================================*/
+PRIVATE void ss_init(void)
+{
+	int i, j;
+	
+	/* Initialize global variables. */
+	for (i = 0; i < NR_MUTEX; i++) {
+		mutexes[i].state = MUTEX_UNUSED;
+		mutexes[i].holder = 0;
+		mutexes[i].initiator = 0;
+		mutexes[i].wait_queue = NULL;
+		
+		for (j = 0; j < NR_CONDVARS; j++) {
+			mutexes[i].condvars[j].cond_id = j + 1;
+			mutexes[i].condvars[j].wait_queue = NULL;
+		}
+	}
+	
+	reply_queue = NULL;
+}
diff -Naur origsrc/servers/ss/misc.c src/servers/ss/misc.c
--- origsrc/servers/ss/misc.c	1970-01-01 00:00:00.000000000 +0000
+++ src/servers/ss/misc.c	2009-08-31 22:43:46.000000000 +0000
@@ -0,0 +1,50 @@
+/* This file contains a few general purpose syscalls */
+
+#include "ss.h"
+#include <minix/com.h>
+#include <minix/callnr.h>
+#include <unistd.h>
+#include <assert.h>
+#include "param.h"
+
+
+/*===========================================================================*
+ *				do_exit					     *
+ *===========================================================================*/
+PUBLIC int do_exit()
+{
+/* Perform the sync servers portion of the exit(status) system call. */
+    mutex_t *mutex;
+    int i;
+    
+    /* Only PM may do the EXIT call directly. */
+    if (who != PM_PROC_NR) return(EGENERIC);
+    
+    /* for all mutexes check */
+    for (i = 0; i < NR_MUTEX; i++) {
+        mutex = get_mutex(i);
+        if (mutex->state == MUTEX_UNUSED)
+            continue;  /* mutex is unused, go to the next one */
+            
+        /* if the proc that started the mutex exited, release all 
+         * (possibly take action in library code raise a signal)
+         * to inform any left "threads" to terminate by setting the reply flog 
+         * to KILL_ME 
+         */
+        if (mutex->initiator == m_in.exitee) {
+            if (VERBOSE) printf("SS: %s: INITIATOR TERMINATED SO mutex_release_all(%d,KILL_ME)! m_in.exitee = %d\n", __FILE__, i, m_in.exitee);
+            mutex_release_all(i,KILL_ME);
+        }
+        /* if not the initiator, but the lock-holder exited, just unlock the mutex */
+        else if (mutex->state == MUTEX_LOCKED && mutex->holder == m_in.exitee) {
+            if (VERBOSE) printf("SS: %s: LOCKHOLDER TERMINATED SO mutex_unlock(%d)! m_in.exitee = %d\n", __FILE__, i, m_in.exitee);
+            mutex_unlock(i);            
+        }
+        /* TODO (?) in all other cases ignor */
+        else {
+            ;
+        }
+    }
+    
+    return(OK);
+}
diff -Naur origsrc/servers/ss/mutexops.c src/servers/ss/mutexops.c
--- origsrc/servers/ss/mutexops.c	1970-01-01 00:00:00.000000000 +0000
+++ src/servers/ss/mutexops.c	2009-08-31 22:35:06.000000000 +0000
@@ -0,0 +1,141 @@
+#include "ss.h"
+#include "param.h"
+
+/*===========================================================================*
+ *                               do_mutexcreate                              *
+ *===========================================================================*/
+PUBLIC int do_mutexcreate(void)
+{
+	int i;
+	
+	if (VERBOSE > 1) printf("SS: %s: do_mutexcreate() syscall by %d\n", __FILE__, who);
+	
+	for (i = 0; i < NR_MUTEX; i++) {
+		if (mutexes[i].state == MUTEX_UNUSED) {
+			/* Create mutex and return mutex descriptor. */
+			mutexes[i].state     = MUTEX_UNLOCKED;
+			mutexes[i].holder    = 0;
+			mutexes[i].initiator = who;
+			return i;
+		}
+	}
+	
+	/* If this point is reached then the entire array is in use. */
+	return ENOSPC;
+}
+
+/*===========================================================================*
+ *                             do_mutexdestroy                               *
+ *===========================================================================*/
+PUBLIC int do_mutexdestroy(void)
+{
+	mutex_t *mutex;
+	
+	if (VERBOSE > 1) printf("SS: %s: do_mutexdestroy() syscall by %d: md = %d\n", 
+			__FILE__, who, m_in.mutex_desc);
+	
+	/* Check validity of given mutex descriptor. */
+	mutex = get_mutex(m_in.mutex_desc);
+	if (mutex == NULL) {
+		return EINVAL;
+	}
+	
+	if (mutex->state == MUTEX_UNUSED) {
+		/* Mutex does not exist, create it first.*/
+		return EINVAL;
+	} else if (mutex->state == MUTEX_LOCKED) {
+		/* Mutex is locked, unlock it first. */
+		return EBUSY;
+	}
+	
+	/* All is OK, destroy the mutex. */
+	assert(mutex->state == MUTEX_UNLOCKED);
+	mutex->state = MUTEX_UNUSED;
+	return OK;
+}
+
+
+/*===========================================================================*
+ *                               do_mutexlock                                *
+ *===========================================================================*/
+PUBLIC int do_mutexlock(void)
+{
+	mutex_t *mutex;
+	
+	if (VERBOSE > 1) printf("SS: %s: do_mutexlock() syscall by %d: md = %d\n",
+			__FILE__, who, m_in.mutex_desc);
+	
+	/* Check validity of given mutex descriptor. */
+	mutex = get_mutex(m_in.mutex_desc);
+	if (mutex == NULL) {
+		return EINVAL;
+	}
+	
+	if (mutex->state == MUTEX_UNUSED) {
+		/* Mutex does not exist, create it first. */
+		return EINVAL;
+	} else if (mutex->state == MUTEX_LOCKED) {
+		if (mutex->holder == who) {
+			/* Mutex locked, holder is requester. */
+			return EBUSY;
+		} else {
+			/* Mutex locked by someone else, block caller. */
+			wait_t *new = (wait_t *) malloc(sizeof(wait_t));
+			if (new == NULL)
+				return EINVAL;  /* TODO: correct error? */
+			
+			/* Enqueue caller to the mutex' wait_queue. */
+			new->dest  = who;     /* save origin of request */
+			new->value = EINVAL;  /* changed to OK once lock is aquired */
+			new->next  = NULL;
+			wait_enqueue(&mutex->wait_queue, new);
+			
+			/* Do not send out reply yet.  Block lock requester
+			 * until resource becomes available. */
+			return ON_HOLD;
+		}
+	}
+	
+	/* All is OK, lock the mutex. */
+	assert(mutex->state == MUTEX_UNLOCKED);
+	mutex->state = MUTEX_LOCKED;  /* lock mutex */
+	mutex->holder = who;          /* set pid of lock holder */
+	return OK;
+}
+
+
+/*===========================================================================*
+ *                              do_mutexunlock                               *
+ *===========================================================================*/
+PUBLIC int do_mutexunlock(void)
+{
+	mutex_t *mutex;
+	
+	if (VERBOSE > 1) printf("SS: %s: do_mutexunlock() syscall by %d: md = %d\n", 
+			__FILE__, who, m_in.mutex_desc);
+	
+	/* Check validity of given mutex descriptor. */
+	mutex = get_mutex(m_in.mutex_desc);
+	if (mutex == NULL) {
+		return EINVAL;
+	}
+	
+	if (mutex->state == MUTEX_UNUSED) {
+		/* Mutex does not exist, create (and lock) it first. */
+		return EINVAL;
+	} else if (mutex->state == MUTEX_UNLOCKED) {
+		/* Mutex is not locked, cannot unlock it. */
+		return ENOLCK;
+	} else if (mutex->state == MUTEX_LOCKED && mutex->holder != who) {
+		/* Mutex is locked but not by us, cannot unlock it. */
+		return EACCES;
+	}
+	
+	/* Now we can unlock the mutex. */
+	assert(mutex->state == MUTEX_LOCKED);
+	mutex_unlock(m_in.mutex_desc);
+	
+	/* In case there is a new lock owner, the SS main loop will find it in
+	 * the reply queue and it will signal it. */
+	return OK;
+}
diff -Naur origsrc/servers/ss/param.h src/servers/ss/param.h
--- origsrc/servers/ss/param.h	1970-01-01 00:00:00.000000000 +0000
+++ src/servers/ss/param.h	2009-08-31 05:02:44.000000000 +0000
@@ -0,0 +1,7 @@
+/* The following names are synonyms for the variables in the input message. */
+#define mutex_desc        m1_i1
+#define cond_id           m1_i2
+#define mutex_signal      m1_i2
+
+/* The following names are used to inform the SS about certain events. */
+#define exitee            m1_i1
diff -Naur origsrc/servers/ss/proto.h src/servers/ss/proto.h
--- origsrc/servers/ss/proto.h	1970-01-01 00:00:00.000000000 +0000
+++ src/servers/ss/proto.h	2009-08-31 22:27:06.000000000 +0000
@@ -0,0 +1,29 @@
+/* Function prototypes. */
+
+#include <timers.h>
+
+/* main.c */
+_PROTOTYPE( int main, (void)						    );
+
+/* mutexops.c */
+_PROTOTYPE( int do_mutexcreate, (void)                  );
+_PROTOTYPE( int do_mutexdestroy, (void)                 );
+_PROTOTYPE( int do_mutexlock, (void)                    );
+_PROTOTYPE( int do_mutexunlock, (void)                  ); 
+
+/* condvars.c */
+_PROTOTYPE( int do_condwait, (void)                     );
+_PROTOTYPE( int do_condsignal, (void)                   );
+
+/* misc.c */
+_PROTOTYPE( int do_exit, (void)						    );
+
+/* utility.c */
+_PROTOTYPE( int no_sys, (void)						    );
+_PROTOTYPE( void panic, (char *who, char *mess, int num));
+_PROTOTYPE( void mutex_release_all, (int mutex_desc, int return_value));
+_PROTOTYPE( void mutex_unlock, (int mutex_desc)          );
+_PROTOTYPE( mutex_t *get_mutex, (int md)                         );
+_PROTOTYPE( condvar_t *get_condvar, (mutex_t *mutex, int cvd)    );
+_PROTOTYPE( void wait_enqueue, (wait_t **queue, wait_t *new)     );
+_PROTOTYPE( wait_t *wait_dequeue, (wait_t **queue)               );
diff -Naur origsrc/servers/ss/ss.h src/servers/ss/ss.h
--- origsrc/servers/ss/ss.h	1970-01-01 00:00:00.000000000 +0000
+++ src/servers/ss/ss.h	2009-08-31 22:44:28.000000000 +0000
@@ -0,0 +1,28 @@
+/* This is the master header for fs.  It includes some other files
+ * and defines the principal constants.
+ */
+#define _POSIX_SOURCE      1	/* tell headers to include POSIX stuff */
+#define _MINIX             1	/* tell headers to include MINIX stuff */
+#define _SYSTEM            1	/* tell headers that this is the kernel */
+
+#include <minix/config.h>
+#include <ansi.h>		
+#include <sys/types.h>
+#include <minix/const.h>
+#include <minix/type.h>
+#include <minix/dmap.h>
+#include <minix/com.h>
+#include <minix/callnr.h>
+#include <limits.h>
+#include <errno.h>
+#include <assert.h>
+
+#include <minix/syslib.h>
+#include <minix/sysutil.h>
+#include <stdlib.h>
+
+#include "const.h"
+#include "type.h"
+#include "glo.h"
+#include "proto.h"
+
diff -Naur origsrc/servers/ss/table.c src/servers/ss/table.c
--- origsrc/servers/ss/table.c	1970-01-01 00:00:00.000000000 +0000
+++ src/servers/ss/table.c	2009-08-31 22:25:11.000000000 +0000
@@ -0,0 +1,116 @@
+/* This file contains the table used to map system call numbers onto the
+ * routines that perform them.
+ */
+
+#define _TABLE
+
+#include "ss.h"
+#include <minix/callnr.h>
+#include <signal.h>
+#include "param.h"
+
+
+_PROTOTYPE (int (*call_vec[NCALLS]), (void) ) = {
+	no_sys,		/*  0 = unused	*/
+	do_exit,	/*  1 = exit	*/
+	no_sys,	    /*  2 = fork	*/
+	no_sys,		/*  3 = read	*/
+	no_sys,		/*  4 = write	*/
+	no_sys,		/*  5 = open	*/
+	no_sys,		/*  6 = close	*/
+	no_sys,	    /*  7 = wait	*/
+	no_sys,		/*  8 = creat	*/
+	no_sys,		/*  9 = link	*/
+	no_sys,		/* 10 = unlink	*/
+	no_sys,	    /* 11 = waitpid	*/
+	no_sys,		/* 12 = chdir	*/
+	no_sys,	    /* 13 = time	*/
+	no_sys,		/* 14 = mknod	*/
+	no_sys,		/* 15 = chmod	*/
+	no_sys,		/* 16 = chown	*/
+	no_sys,		/* 17 = break	*/
+	no_sys,		/* 18 = stat	*/
+	no_sys,		/* 19 = lseek	*/
+	no_sys,	    /* 20 = getpid	*/
+	no_sys,		/* 21 = mount	*/
+	no_sys,		/* 22 = umount	*/
+	no_sys,	    /* 23 = setuid	*/
+	no_sys,	    /* 24 = getuid	*/
+	no_sys,	    /* 25 = stime	*/
+	no_sys,	    /* 26 = ptrace	*/
+	no_sys,	    /* 27 = alarm	*/
+	no_sys,		/* 28 = fstat	*/
+	no_sys,	    /* 29 = pause	*/
+	no_sys,		/* 30 = utime	*/
+	no_sys,		/* 31 = (stty)	*/
+	no_sys,		/* 32 = (gtty)	*/
+	no_sys,		/* 33 = access	*/
+	no_sys,		/* 34 = (nice)	*/
+	no_sys,		/* 35 = (ftime)	*/
+	no_sys,		/* 36 = sync	*/
+	no_sys,	    /* 37 = kill	*/
+	no_sys,		/* 38 = rename	*/
+	no_sys,		/* 39 = mkdir	*/
+	no_sys,		/* 40 = rmdir	*/
+	no_sys,		/* 41 = dup	*/
+	no_sys,		/* 42 = pipe	*/
+	no_sys,	    /* 43 = times	*/
+	no_sys,		/* 44 = (prof)	*/
+	no_sys,		/* 45 = unused	*/
+	no_sys,	    /* 46 = setgid	*/
+	no_sys,	    /* 47 = getgid	*/
+	no_sys,		/* 48 = (signal)*/
+	no_sys,		/* 49 = unused	*/
+	no_sys,		/* 50 = unused	*/
+	no_sys,		/* 51 = (acct)	*/
+	no_sys,		/* 52 = (phys)	*/
+	no_sys,		/* 53 = (lock)	*/
+	no_sys,		/* 54 = ioctl	*/
+	no_sys,		/* 55 = fcntl	*/
+	no_sys,		/* 56 = (mpx)	*/
+	no_sys,		/* 57 = unused	*/
+	no_sys,		/* 58 = unused	*/
+	no_sys,	    /* 59 = execve	*/
+	no_sys,		/* 60 = umask	*/
+	no_sys,		/* 61 = chroot	*/
+	no_sys,	    /* 62 = setsid	*/
+	no_sys,	    /* 63 = getpgrp	*/
+
+	no_sys,		/* 64 = unused */
+	no_sys,		/* 65 = UNPAUSE	*/
+	no_sys, 	/* 66 = unused  */
+	no_sys,		/* 67 = REVIVE	*/
+	no_sys,		/* 68 = TASK_REPLY  */
+	no_sys,		/* 69 = unused	*/
+	no_sys,		/* 70 = unused	*/
+	no_sys,	    /* 71 = sigaction   */
+	no_sys,	    /* 72 = sigsuspend  */
+	no_sys,	    /* 73 = sigpending  */
+	no_sys,	    /* 74 = sigprocmask */
+	no_sys,	    /* 75 = sigreturn   */
+	no_sys,	    /* 76 = reboot	*/
+	no_sys,	    /* 77 = svrctl	*/
+
+	no_sys,		/* 78 = unused */
+	no_sys,	    /* 79 = getsysinfo */
+	no_sys,	    /* 80 = getprocnr */
+	no_sys, 	/* 81 = unused */
+	no_sys, 	/* 82 = fstatfs */
+	no_sys, 	/* 83 = memalloc */
+	no_sys, 	/* 84 = memfree */
+	no_sys,		/* 85 = select */
+	no_sys,		/* 86 = fchdir */
+	no_sys,		/* 87 = fsync */
+	no_sys,	    /* 88 = getpriority */
+	no_sys,	    /* 89 = setpriority */
+	no_sys,	    /* 90 = gettimeofday */
+	
+	do_mutexcreate,    /* 91 = mutexcreate */
+	do_mutexdestroy,   /* 92 = mutexdestroy */
+	do_mutexlock,      /* 93 = mutexlock */
+	do_mutexunlock,    /* 94 = mutexunlock */
+	do_condwait,       /* 95 = condwait */
+	do_condsignal,     /* 96 = condsignal */
+};
+/* This should not fail with "array size is negative": */
+extern int dummy[sizeof(call_vec) == NCALLS * sizeof(call_vec[0]) ? 1 : -1];
diff -Naur origsrc/servers/ss/type.h src/servers/ss/type.h
--- origsrc/servers/ss/type.h	1970-01-01 00:00:00.000000000 +0000
+++ src/servers/ss/type.h	2009-08-29 19:10:33.000000000 +0000
@@ -0,0 +1,35 @@
+
+typedef struct wait_s {
+	int dest;             /* who is waiting for the lock? */
+	int value;            /* message to send if put on reply queue */
+	struct wait_s *next;  /* pointer to next */
+} wait_t;
+
+/* Data structure for condvar administration. */
+typedef struct {
+	int cond_id;
+	wait_t *wait_queue;
+} condvar_t;
+
+/* Data structure for mutex administration. */
+typedef struct {
+	int state;           /* MUTEX_UNUSED, MUTEX_UNLOCKED, or MUTEX_LOCKED */
+	int holder;          /* if MUTEX_LOCKED, who is holding the lock? */
+	int initiator;       /* who created the mutex? */
+	
+	wait_t *wait_queue;  /* linked list of processes requesting the lock */
+	condvar_t condvars[NR_CONDVARS];  /* array of condition variables */
+} mutex_t;
+
+
+
+
+
+
+/* Declaration of the mutex operation&reply node: 
+ * used for message queue & reply operations */
+struct m_node {
+    int             m_dest;     /*who issued the command or should be reply destination*/
+    int             m_value;    /*value requested or value to be send*/
+    struct m_node   *next;      /*pointer to next queued m_node*/
+};
diff -Naur origsrc/servers/ss/utility.c src/servers/ss/utility.c
--- origsrc/servers/ss/utility.c	1970-01-01 00:00:00.000000000 +0000
+++ src/servers/ss/utility.c	2009-08-31 22:33:05.000000000 +0000
@@ -0,0 +1,198 @@
+/* This file contains a few general purpose utility routines.
+ *
+ * The entry points into this file are
+ *   no_sys:      reject a system call that SYNC does not handle
+ *   panic:       something awful has occurred;  MINIX cannot continue
+ */
+
+#include "ss.h"
+#include <minix/com.h>
+#include <unistd.h>
+#include <assert.h>
+#include "param.h"
+
+
+/*===========================================================================*
+ *				no_sys					     *
+ *===========================================================================*/
+PUBLIC int no_sys()
+{
+/* Somebody has used an illegal system call number */
+  return(EINVAL);
+}
+
+/*===========================================================================*
+ *				panic					     *
+ *===========================================================================*/
+/*  struct var init:
+ *  TODO create a generic error. 
+ *  used as default in case the SS crashes 
+ *  and all blocking processes need to be told 
+ */
+PUBLIC void panic(who, mess, num)
+char *who;			/* who caused the panic */
+char *mess;			/* panic message string */
+int num;			/* number to go with it */
+{
+	/* Something awful has happened.  Panics are caused when an internal
+	 * inconsistency is detected, e.g., a programming error or illegal
+	 * value of a defined constant. */
+	
+	printf("SS: panic (%s): %s ", who, mess);
+	if (num != NO_NUM) printf("%d",num);
+	printf("\n"); 
+	exit(EGENERIC);
+}
+
+
+/*===========================================================================*
+ *				mutex_release_all					     *
+ *===========================================================================*/
+/* release all procs still on-hold on in mutex_desc's queues, set message 
+ * return value to rValue
+ * And set mutex state to unused, so other procs can use the mutex.
+ * AKA the "automatically released" requirement from hints and notes section
+ */
+PUBLIC void mutex_release_all(int md, int rValue) {
+    int i;
+    mutex_t *mutex;
+    condvar_t *condvar;
+    wait_t *new;
+        
+    /* Check validity of given mutex descriptor. */
+    mutex = get_mutex(md);
+    assert(mutex != NULL);
+    if (mutex->state == MUTEX_UNUSED)
+        return;  /* mutex is unused, return */
+	
+	/* release all pending locks. */
+    while (mutex->wait_queue != NULL) {
+		wait_t *new = wait_dequeue(&mutex->wait_queue);
+		new->value = rValue;    /* forward signal */
+		wait_enqueue(&reply_queue, new);
+		if (VERBOSE > 1) printf("SS: %s: mutex_release_all(): send error to %d\n", __FILE__, new->dest);
+	}
+	
+	/* unlock blocked calls by replying */		
+	for (i = 0; i < NR_CONDVARS; i++) {
+		/* Check validity of given condition variable descriptor. */
+    	condvar_t *condvar = get_condvar(mutex, i);
+    	if (condvar != NULL) {
+        	while (condvar->wait_queue != NULL) {
+        		wait_t *new = wait_dequeue(&condvar->wait_queue);
+        		new->value = rValue;    /* forward signal */
+        		wait_enqueue(&reply_queue, new);
+        		if (VERBOSE > 1) printf("SS: %s: mutex_release_all(): moved from condvar to mutex wait_queue.\n",__FILE__);
+        	}
+    	}
+	}
+    
+    if (VERBOSE) printf("SS: %s: mutex_release_all(): set mutex status to MUTEX_UNUSED\n",__FILE__);
+    /* finally release the mutex */
+	mutex->state = MUTEX_UNUSED;
+    mutex->holder = 0;
+	mutex->initiator = 0;
+	assert(mutex->wait_queue == NULL);
+	            		
+	return;
+}
+
+
+/*===========================================================================*
+ *				mutex_unlock					     *
+ *===========================================================================*/
+PUBLIC void mutex_unlock(int md) {
+    mutex_t *mutex;
+	
+	/* Check validity of given mutex descriptor. */
+	mutex = get_mutex(md);
+	if (mutex == NULL) {
+		return;
+	}
+    
+    /* Now we can unlock the mutex. */
+	if (mutex->wait_queue != NULL) {
+		/* If there is a pending lock request for this mutex, we must
+		 * pass on the lock.  Remove the first element from the mutex'
+		 * wait_queue and put it on the global reply_queue. */
+		wait_t *new = wait_dequeue(&mutex->wait_queue);
+		mutex->holder = new->dest;
+		new->value = OK;  /* send OK to lock requester */
+		wait_enqueue(&reply_queue, new);
+		if (VERBOSE > 1) printf("SS: %s: changed lock holder to %d\n", __FILE__, mutex->holder);
+	} else {
+		/* Otherwise, unlock it. */
+		mutex->state = MUTEX_UNLOCKED;
+	}
+	
+	return;
+}
+
+
+
+/*===========================================================================*
+ *				get_mutex					     *
+ *===========================================================================*/
+PUBLIC mutex_t *get_mutex(md)
+int md;
+{
+	if (md < 0 || md >= NR_MUTEX) {
+		return NULL;
+	}
+	return &mutexes[md];
+}
+
+/*===========================================================================*
+ *				get_condvar					     *
+ *===========================================================================*/
+PUBLIC condvar_t *get_condvar(mutex, cvd)
+mutex_t *mutex;
+int cvd;
+{
+	cvd--;  /* cvd is nonzero positive, translate to array index */
+	if (cvd < 0 || cvd >= NR_CONDVARS) {
+		return NULL;
+	}
+	return &mutex->condvars[cvd];
+}
+
+
+/*===========================================================================*
+ *				wait_enqueue					     *
+ *===========================================================================*/
+PUBLIC void wait_enqueue(queue, new)
+wait_t **queue;     /* add to this queue */
+wait_t *new;        /* add this element (already malloc'd and filled) */
+{
+	if (*queue == NULL) {
+		/* Linked list is empty, new is first element. */
+		*queue = new;
+	} else {
+		/* Find the last element. */
+		wait_t *tail = *queue;
+		while (tail->next != NULL) {
+			tail = tail->next;
+		}
+		
+		/* And add new to it. */
+		tail->next = new;
+	}
+}
+
+
+/*===========================================================================*
+ *				wait_dequeue					     *
+ *===========================================================================*/
+PUBLIC wait_t *wait_dequeue(queue)
+wait_t **queue;     /* get first waiting from this mutex */
+{
+	if (*queue == NULL) {
+		return NULL;  /* nothing to dequeue! */
+	} else {
+		wait_t *head = *queue;
+		*queue = head->next;
+		head->next = NULL;
+		return head;
+	}
+}
+
diff -Naur origsrc/kernel/table.c src/kernel/table.c
--- origsrc/kernel/table.c	2005-10-02 19:00:17.000000000 +0000
+++ src/kernel/table.c	2009-08-29 19:10:33.000000000 +0000
@@ -68,7 +68,7 @@
 #define s(n)		(1 << s_nr_to_id(n))
 #define SRV_M (~0)
 #define SYS_M (~0)
-#define USR_M (s(PM_PROC_NR) | s(FS_PROC_NR) | s(RS_PROC_NR))
+#define USR_M (s(PM_PROC_NR) | s(FS_PROC_NR) | s(RS_PROC_NR) | s(SS_PROC_NR))
 #define DRV_M (USR_M | s(SYSTEM) | s(CLOCK) | s(LOG_PROC_NR) | s(TTY_PROC_NR))
 
 /* Define kernel calls that processes are allowed to make. This is not looking
@@ -85,6 +85,8 @@
 #define DRV_C	(FS_C | c(SYS_SEGCTL) | c(SYS_IRQCTL) | c(SYS_INT86) \
     | c(SYS_DEVIO) | c(SYS_VDEVIO) | c(SYS_SDEVIO)) 
 #define MEM_C	(DRV_C | c(SYS_PHYSCOPY) | c(SYS_PHYSVCOPY))
+#define SS_C  ~0
+
 
 /* The system image table lists all programs that are part of the boot image. 
  * The order of the entries here MUST agree with the order of the programs
@@ -106,6 +108,7 @@
  { MEM_PROC_NR,   0, SRV_F,  4,      2, 0,     SRV_T, DRV_M, MEM_C, "memory"},
  { LOG_PROC_NR,   0, SRV_F,  4,      2, 0,     SRV_T, SYS_M, DRV_C, "log"   },
  { DRVR_PROC_NR,  0, SRV_F,  4,      2, 0,     SRV_T, SYS_M, DRV_C, "driver"},
+ { SS_PROC_NR,    0, SRV_F,  8,      3, 0,     SRV_T, SRV_M,     0, "ss"  },
  { INIT_PROC_NR,  0, USR_F,  8, USER_Q, 0,     USR_T, USR_M,     0, "init"  },
 };
 
diff -Naur origsrc/extra/4v_test.c src/extra/4v_test.c
--- origsrc/extra/4v_test.c	1970-01-01 00:00:00.000000000 +0000
+++ src/extra/4v_test.c	2009-08-29 20:52:39.000000000 +0000
@@ -0,0 +1,65 @@
+#include <stdio.h>
+#include <lib.h>
+#include <unistd.h> 
+#include <errno.h>
+#include "lib/i386/conc.h"
+
+#define OK          0
+#define NR_FORKS    10
+#define COND_VAR    6
+
+/*NOTES TO SELF: found that message params are reset after send!*/
+
+/**/
+int main(int argc, char* argv[]) {
+    pid_t child;
+    int i, result, mFd;
+    
+    /* create a mutex file descriptor for further testing */
+    mFd = mutex_create();
+    if (mFd == ENOSPC)
+        ;   
+    
+    /* write some data to shared state */
+    thread_state(1, "%d,%d", 50, 100);
+    
+    if (VERBOSE > 1) printf("NR_FORKS = %d\n", NR_FORKS);
+    
+    /* create NR_FORKS number of threads */
+    for (i = 0; i < NR_FORKS; i++) {
+        /* Child process: */
+        if ((child = fork()) == 0) { 
+            int i, j;
+            /* let parent get lock first. */ 
+            sleep(1);
+            /* acquire a lock existing mutex */
+            result = mutex_lock(mFd);
+            /* read thread_state */            
+            thread_state(0, "%d,%d", &i, &j);
+            printf("CHILD %d: i = %d, j = %d\n", getpid(), i, j);
+            /* write some data to shared state */
+            thread_state(1, "%d,%d", ++i, --j);
+            /* send a signal to the parent */
+            result = cond_signal(mFd, COND_VAR);
+            /* unlock */
+            result = mutex_unlock(mFd);
+            break;	    
+        }            
+    }
+    /* Parent prcess */
+    if (child) { 
+        /* create a lock */
+        result = mutex_lock(mFd);
+        /*let the child request the lock to test blocking*/
+        sleep(2);
+        /* write some data to shared state */
+        thread_state(1, "%d,%d", 200, 200);
+        /* cond_wait so child can set issue cond wait calls */
+        result = cond_wait(mFd, COND_VAR);
+        /* unlock: */
+        result = mutex_unlock(mFd);
+        /* destroy: */
+        result = mutex_destroy(mFd);
+    }
+    return(0);
+}
\ No newline at end of file
diff -Naur origsrc/extra/5v_test.c src/extra/5v_test.c
--- origsrc/extra/5v_test.c	1970-01-01 00:00:00.000000000 +0000
+++ src/extra/5v_test.c	2009-08-31 23:50:50.000000000 +0000
@@ -0,0 +1,117 @@
+#include <stdio.h>
+#include <lib.h>
+#include <unistd.h> 
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <signal.h>
+#include <stdarg.h>
+#include <assert.h>
+#include "lib/i386/conc.h"
+
+#define OK              0
+#define NR_THREADS      10
+#define COND_HALFWAY    6
+#define COND_FINISHED   7
+
+/* global vars */
+int r, md;
+
+char    *str1 = "Hyori Lee", 
+        *str2 = "Boa Kwon";
+
+void fatal(const char *description, ...)
+{
+    va_list args;
+    va_start(args, description);
+    vfprintf(stderr, description, args);
+    va_end(args);
+    fprintf(stderr, "\n");
+    exit(EXIT_FAILURE);
+}
+
+void orig_sighandler(int sig)
+/* test to see if original signal handler will be restored */
+{
+    printf("%d reached original signal handler. YEAH! :)\n",getpid());
+    /* reset to default */
+    (void) signal(SIGINT, SIG_DFL);
+    raise(sig);
+}
+
+void display(char *str)
+/* Replacement for printf, intermixes strings if called concurrently. */
+{
+    char *tmp;
+    for (tmp=str; *tmp; tmp++) {
+        write(1,tmp,1);
+        usleep(100);
+    }
+}
+
+void t_print(void *param)
+{
+    int i;
+    /*char *str = (char *) param;*/
+    
+    for (i=0; i<5; i++) {
+        r = mutex_lock(md);
+        /* read some data to shared state */
+        /*thread_state(0, "%s,%s", &str1, &str2);*/
+        display(str1);
+        display("\n");
+        /* write some data to shared state */
+        /*thread_state(1, "%s,%s", str2, str1);*/
+        r = mutex_unlock(md);
+    }
+    r = mutex_lock(md);
+    /* signal the parent */
+    r = cond_signal(md, COND_FINISHED);
+    r = mutex_unlock(md);
+}
+
+/**/
+int main(int argc, char* argv[]) 
+{
+    int i;
+            
+    /* overwrite file descriptor, to see if original filedescriptor is set back */
+    /*(void) signal(SIGINT, orig_sighandler);*/
+            
+    /* cmdreate a mutex file descriptor for further testing */
+    md = mutex_create();
+    if (md < 0) fatal("mutex_create() failed: %s", strerror(errno));
+        
+    r = mutex_lock(md); /* grap the lock */
+    
+    /* write some data to shared state */
+    thread_state(1, "%s,%s", str1, str2);
+    printf("%d: str1 = %s, str2 = %s\n", getpid(), str1, str2);
+    
+    for (i = 0; i < NR_THREADS; i++)
+        r = thread_init(t_print, (void *) str1); /* initiate first */
+        
+    /*for (i = 0; i < NR_THREADS; i++)*/
+        r = cond_wait(md, COND_FINISHED); /* wait for a signal from a child */
+        
+    /* raise(SIGTERM); */
+    
+    /* read some data to shared state */
+    /*thread_state(0, "%s,%s", &str1, &str2);
+    printf("%d: str1 = %s, str2 = %s\n", getpid(), str1, str2);*/
+    
+    r = mutex_unlock(md);  /* release the lock */
+    
+    
+    for (i = 0; i < NR_THREADS; i++)    
+        printf("PARENT (%d) NOW GOING TO SLEEP FOR 20 SECS!!!\n", getpid());
+    sleep(20);
+    
+    /*raise(SIGTERM);*/
+    
+    /* destroy the mutex */
+    if (mutex_destroy(md) < 0)
+        fatal("mutex_destroy() failed: %s", strerror(errno)); 
+    
+    return(EXIT_SUCCESS);
+}
\ No newline at end of file
diff -Naur origsrc/extra/6v_test.c src/extra/6v_test.c
--- origsrc/extra/6v_test.c	1970-01-01 00:00:00.000000000 +0000
+++ src/extra/6v_test.c	2009-08-31 23:53:21.000000000 +0000
@@ -0,0 +1,140 @@
+#include <stdio.h>
+#include <lib.h>
+#include <unistd.h> 
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <signal.h>
+#include <stdarg.h>
+#include <assert.h>
+#include "lib/i386/conc.h"
+
+#define OK              0
+#define NR_THREADS      5
+#define COND_HALFWAY    6
+#define COND_FINISHED   7
+
+/* global vars */
+int r, md, md2;
+
+char    *str1 = "Hyori Lee", 
+        *str2 = "Boa Kwon";
+
+void fatal(const char *description, ...)
+{
+    va_list args;
+    va_start(args, description);
+    vfprintf(stderr, description, args);
+    va_end(args);
+    fprintf(stderr, "\n");
+    exit(EXIT_FAILURE);
+}
+
+void display(char *str)
+/* Replacement for printf, intermixes strings if called concurrently. */
+{
+    char *tmp;
+    for (tmp=str; *tmp; tmp++) {
+        write(1,tmp,1);
+        usleep(100);
+    }
+}
+
+void t_print_2(void *param)
+{
+    int i;
+    /*char *str = (char *) param;*/
+    
+    for (i=0; i<5; i++) {
+        r = mutex_lock(md2);
+        /* read some data to shared state */
+        /*thread_state(0, "%s,%s", &str1, &str2);*/
+        display("t_print_2\t");
+        display(str2);
+        display("\n");
+        /* write some data to shared state */
+        /*thread_state(1, "%s,%s", str2, str1);*/
+        r = mutex_unlock(md2);
+    }
+    r = mutex_lock(md2);
+    r = cond_signal(md2, COND_FINISHED);
+    r = mutex_unlock(md2);
+}
+
+void t_print(void *param)
+{
+    int i;
+    /*char *str = (char *) param;*/
+    
+    for (i=0; i<5; i++) {
+        r = mutex_lock(md);
+        /* read some data to shared state */
+        /*thread_state(0, "%s,%s", &str1, &str2);*/
+        display("t_print \t");
+        display(str1);
+        display("\n");
+        /* write some data to shared state */
+        /*thread_state(1, "%s,%s", str2, str1);*/
+        r = mutex_unlock(md);
+    }
+    thread_init(t_print_2, (void *) str1); /* initiate first */
+    r = mutex_lock(md);
+    /* signal the parent */
+    r = cond_signal(md, COND_FINISHED);
+    r = mutex_unlock(md);
+}
+
+/**/
+int main(int argc, char* argv[]) 
+{
+    int i;
+            
+    /* overwrite file descriptor, to see if original filedescriptor is set back */
+    /*(void) signal(SIGINT, orig_sighandler);*/
+            
+    /* cmdreate a mutex file descriptor for further testing */
+    md = mutex_create();
+    if (md < 0) fatal("mutex_create() failed: %s", strerror(errno));
+    md2 = mutex_create();
+    if (md2 < 0) fatal("mutex_create() failed: %s", strerror(errno));
+    
+    r = mutex_lock(md); /* grap the lock */
+    r = mutex_lock(md2);
+    
+    /* write some data to shared state */
+    thread_state(1, "%s,%s", str1, str2);
+    printf("%d: str1 = %s, str2 = %s\n", getpid(), str1, str2);
+    
+    for (i = 0; i < NR_THREADS; i++)
+        r = thread_init(t_print, (void *) str1); /* initiate first */
+        
+    /*for (i = 0; i < NR_THREADS; i++)*/
+    r = cond_wait(md, COND_FINISHED); /* wait for a signal from a child */
+        
+    r = mutex_unlock(md2);
+    /* raise(SIGTERM); */
+    
+    /* read some data to shared state */
+    /*thread_state(0, "%s,%s", &str1, &str2);
+    printf("%d: str1 = %s, str2 = %s\n", getpid(), str1, str2);*/
+    
+    r = cond_wait(md2, COND_FINISHED); /* wait for a signal from a child */
+    
+    r = mutex_unlock(md);  /* release the lock */
+    
+    /*for (i = 0; i < NR_THREADS; i++)    */
+    printf("PARENT (%d) NOW GOING TO SLEEP FOR 15 SECS!!!\n", getpid());
+    sleep(15);
+    
+    /*raise(SIGTERM);*/
+    printf("PARENT (%d) NOW GOING TO DESTROY 2 MUTEX DESCRIPTORS!!!\n", getpid());
+    /* destroy the mutex */
+    if (mutex_destroy(md) < 0)
+        fatal("mutex_destroy() failed: %s", strerror(errno)); 
+    /* destroy the mutex */
+    if (mutex_destroy(md2) < 0)
+        fatal("mutex_destroy() failed: %s", strerror(errno)); 
+    
+    printf("PARENT (%d) ALL OK, BYE!!!\n", getpid());
+    return(EXIT_SUCCESS);
+}
\ No newline at end of file
diff -Naur origsrc/extra/Makefile src/extra/Makefile
--- origsrc/extra/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ src/extra/Makefile	2009-08-31 19:02:25.000000000 +0000
@@ -0,0 +1,15 @@
+# Makefile for (sync server test user progs)
+all: library build clean
+
+library:
+	cd lib/i386 && exec make
+
+build:
+	cc 4v_test.c -Llib -lconc lib/i386/libconc.a -o 4v_test
+	cc 5v_test.c -Llib -lconc lib/i386/libconc.a -o 5v_test  
+	cc testthreads_basic.c -Llib -lconc lib/i386/libconc.a -o testthreads_basic  
+	cc 6v_test.c -Llib -lconc lib/i386/libconc.a -o 6v_test
+    
+clean:
+	cd lib/i386 && exec make clean
+	rm -rf *.o
diff -Naur origsrc/extra/lib/i386/Makefile src/extra/lib/i386/Makefile
--- origsrc/extra/lib/i386/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ src/extra/lib/i386/Makefile	2009-08-29 19:10:33.000000000 +0000
@@ -0,0 +1,24 @@
+# Practical Operating Systems 2008/2009
+# Makefile for concurrency library (assignment 3)
+#
+# Richard van Heuven van Staereling  <richard@few.vu.nl>
+# Marc Hage                          <mrhage@few.vu.nl>
+
+MAKE	= exec make
+CC	= cc
+AR	= aal
+RANLIB	= touch
+CFLAGS	= -g -Wall
+RM	= rm -f
+
+default: libconc.a
+
+libconc.a: conc.o
+	$(AR) r libconc.a conc.o
+	$(RANLIB) libconc.a
+
+conc.o: conc.c conc.h
+	$(CC) $(CFLAGS) -o $@ -c $<
+
+clean:
+	$(RM) libconc.a *.o *~ core
diff -Naur origsrc/extra/lib/i386/conc.c src/extra/lib/i386/conc.c
--- origsrc/extra/lib/i386/conc.c	1970-01-01 00:00:00.000000000 +0000
+++ src/extra/lib/i386/conc.c	2009-08-31 23:49:43.000000000 +0000
@@ -0,0 +1,245 @@
+#include <minix/callnr.h>
+#include <minix/com.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <unistd.h>
+#include <assert.h>
+#include <lib.h>
+ 
+#include <errno.h>
+
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <signal.h>
+
+#include "conc.h"
+
+#define MAX_T   100
+#define MAX_DATA 4096
+#define SIGTYP void
+#define T_INT   -100
+#define T_TERM  -200
+#define T_HUP   -300
+#define T_QUIT  -400
+#define KILL_ME -2048
+
+/* global variables */
+message m;  /* message for system calls */
+
+typedef pid_t thread_t;
+/* TODO FUGLY, use pointer? Nope, simple memory management */
+thread_t threads[MAX_T]; /* stores all spawned threads */
+int n_threads = 0;
+
+
+/* checks if returned message contains a signal to stop */
+int check_for_signal(int r)
+{
+    /* Uninterruptible sleep
+     * When the process is sleeping uninterruptibly, the signal will be noticed 
+     * when the process returns from the system call or trap.
+     */
+    switch(r) {
+        case KILL_ME:
+            raise(SIGTERM);
+            break;
+        default:
+            return r;
+    }
+}
+
+/* create a mutex file descriptor */
+int mutex_create(void) 
+{
+    int r;
+    if (VERBOSE > 1) printf("%d: ABOUT TO mutex_create()\n", getpid());
+    r = _syscall(SS,MUTEXCREATE,&m);
+    if (VERBOSE) printf("%d: mutex_create() r = %d\n", getpid(), r);    
+    
+    /* return mutex descriptor or error */
+    return r;
+}
+
+
+/* destroy an existing mutex */
+int mutex_destroy(int mutex_desc)
+{
+    int r;
+    m.m1_i1 = mutex_desc;
+    if (VERBOSE > 1) printf("%d: ABOUT TO mutex_destroy()\n", getpid());
+    r = _syscall(SS,MUTEXDESROY,&m);
+    if (VERBOSE) printf("%d: RETURNED mutex_destroy() r = %d\n", getpid(), r);
+    return r;
+}
+
+
+/* acquire a lock an existing mutex */
+int mutex_lock(int mutex_desc)
+{
+    int r;    
+    if (VERBOSE > 1) printf("%d: ABOUT TO mutex_lock()\n", getpid());
+    m.m1_i1 = mutex_desc;
+    r = _syscall(SS,MUTEXLOCK,&m);
+    if (VERBOSE) printf("%d: RETURNED mutex_lock() r = %d\n", getpid(), r);    
+    return (check_for_signal(r));
+}
+
+
+/* release a lock on an existing mutex */
+int mutex_unlock(int mutex_desc)
+{
+    int r;
+    if (VERBOSE > 1) printf("%d: ABOUT TO mutex_unlock()\n", getpid());
+    m.m1_i1 = mutex_desc;
+    r = _syscall(SS,MUTEXUNLOCK,&m);
+    if (VERBOSE) printf("%d: RETURNED mutex_unlock() r = %d\n", getpid(), r);    
+    return r;
+}
+
+
+/* wait until the condition is signaled */
+int cond_wait(int mutex_desc, int cond_id)
+{
+    int r;
+    if (VERBOSE > 1) printf("%d: ABOUT TO cond_wait()\n", getpid());
+    m.m1_i1 = mutex_desc;
+    m.m1_i2 = cond_id;
+    r = _syscall(SS,CONDWAIT,&m);
+    if (VERBOSE) printf("%d: RETURNED cond_wait() r = %d\n", getpid(), r);
+    /* if a signal was send to terminate, check_for_signal will handle it */
+    return(check_for_signal(r));
+}
+
+
+/* signal that a condition is now true */
+int cond_signal(int mutex_desc, int cond_id)
+{
+    int r;
+    if (VERBOSE > 1) printf("%d: ABOUT TO cond_signal()\n", getpid());
+    m.m1_i1 = mutex_desc;
+    m.m1_i2 = cond_id;
+    r = _syscall(SS,CONDSIGNAL,&m);
+    if (VERBOSE) printf("%d: RETURNED cond_signal() r = %d\n", getpid(), r);
+    return r;
+}
+
+
+
+
+/* start a new processing thread and execute the given function with the given 
+ * argument. Upon successful completion, return 0. Otherwise, return -1 and set 
+ * the errno error status to an appropriate value.  
+ */
+int thread_init(void (*function)(void *), void *arg1)
+{
+    pid_t child;
+    int i;
+    
+    child = fork();
+    if (child == 0) {  /* child, runs the threading function */
+        /* child should not have any spawned threads inherited from parent,
+         * but should fill the structure itself
+         */
+        for (i = 0; i < MAX_T; i++)  
+            threads[i] == child; /* set to 0 */
+        if (VERBOSE > 1) printf("%d (child): ABOUT TO START FUNCTION CALL in threat_init()\n", getpid());
+        /* Run the supplied function. */
+        (*function) (arg1);
+        if (VERBOSE > 1) printf("%d: (child) REACHED POINT AFTER FUNCTION in threat_init()!\n", getpid());
+        /* TODO use exit status of function? */        
+        exit(EXIT_SUCCESS);
+    } else {
+        /* only parents should increment */
+        threads[n_threads++] = child;
+        return 0;
+    }
+}
+
+
+/* clean up processing threads that finished; if the blocking flag is not set, 
+ * immediately return if no such thread exist. Upon successful completion, 
+ * return 0. If an error occurs, return -1 and set the errno error status to an 
+ * appropriate value.  
+ */
+int thread_wait(int blocking_flag)
+{
+    int r, status;
+    if (VERBOSE > 1) printf("%d: ABOUT TO thread_wait()\n", getpid());
+    if (blocking_flag) {
+        pid_t pid;
+        pid = waitpid(-1, &status, 0);
+        if (pid > 0) {
+            int i;
+            for (i=0; i<n_threads; i++) {
+                if (threads[i] == pid) {
+                    threads[i] = threads[--n_threads];
+                }
+            }
+        }
+        while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {
+            int i;
+            for (i=0; i<n_threads; i++) {
+                if (threads[i] == pid) {
+                    threads[i] = threads[--n_threads];
+                }
+            }
+        }
+    } else {
+        pid_t pid;
+        while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {
+            int i;
+            for (i=0; i<n_threads; i++) {
+                if (threads[i] == pid) {
+                    threads[i] = threads[--n_threads];
+                }
+            }
+        }
+    }
+    
+    if (VERBOSE) printf("%d: RETURNED thread_wait() r = %d\n", getpid(), r);
+    return r;
+}
+
+
+/* read or write the shared state based on a format string. All applications are
+ * expected to write initial shared state with this call before calling 
+ * thread_init for the first time. 
+ */
+void thread_state(int w, char *f, ...)
+{
+       static char buf[MAX_DATA];
+       static FILE *state = NULL;
+       va_list l;
+       char *p;
+       int s;
+
+       if (state == NULL) {
+               /* get a handle to a temporary (deleted) file */
+               state = tmpfile();
+               assert(state != NULL);
+       } 
+
+       va_start(l, f);
+       rewind(state);
+       if (w) {
+               /* write format string to file */
+               if (VERBOSE > 1) printf("%d: ABOUT TO WRITE THREAD_STATE\n", getpid());
+               s = vfprintf(state, f, l);
+               assert(s >= 0);
+               s = putc('\n', state);
+               assert(s == '\n');
+               fflush(state);
+       } else {
+               /* read format string from file */
+               /* make up for missing ftruncate(), sort of */
+               if (VERBOSE > 1) printf("%d: ABOUT TO READ THREAD_STATE\n", getpid());
+               p = fgets(buf, sizeof(buf), state);
+               assert(p != NULL);
+               s = vsscanf(p, f, l);
+               assert(s >= 0);
+       }
+       va_end(l);
+}
+
diff -Naur origsrc/extra/lib/i386/conc.h src/extra/lib/i386/conc.h
--- origsrc/extra/lib/i386/conc.h	1970-01-01 00:00:00.000000000 +0000
+++ src/extra/lib/i386/conc.h	2009-08-31 23:04:13.000000000 +0000
@@ -0,0 +1,13 @@
+#define VERBOSE     0
+
+int mutex_create(void);
+int mutex_destroy(int mutex_desc);
+int mutex_lock(int mutex_desc);
+int mutex_unlock(int mutex_desc);
+
+int cond_wait(int mutex_desc, int cond_id);
+int cond_signal(int mutex_desc, int cond_id);
+
+int thread_init(void (*function)(void *), void *arg1);
+int thread_wait(int blocking_flag);
+void thread_state(int write_flag, char *format, ...);
diff -Naur origsrc/extra/testthreads_basic.c src/extra/testthreads_basic.c
--- origsrc/extra/testthreads_basic.c	1970-01-01 00:00:00.000000000 +0000
+++ src/extra/testthreads_basic.c	2009-08-31 15:12:06.000000000 +0000
@@ -0,0 +1,97 @@
+/* Practical Operating Systems 2008/2009
+* testthreads_basic.c
+*
+* Simple test program that creates two threads.  Both threads print 10 strings
+* that should intermix character-wise.  Compile with -DMUTEX to enable mutual
+* exclusion; the strings should still intermix but this time line-wise.
+*
+* At the end, another thread is started that prints 10 strings but the process
+* ends before the thread finishes.  The thread should stop as well.
+*
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+#include <stdarg.h>
+#include <assert.h>
+
+#include "lib/i386/conc.h"
+
+int mutex;
+
+
+void fatal(const char *description, ...)
+{
+    va_list args;
+    va_start(args, description);
+    vfprintf(stderr, description, args);
+    va_end(args);
+    fprintf(stderr, "\n");
+    exit(1);
+}
+
+
+void display(char *str)
+/* Replacement for printf, intermixes strings if called concurrently. */
+{
+    char *tmp;
+    for (tmp=str; *tmp; tmp++) {
+        write(1,tmp,1);
+        usleep(100);
+    }
+}
+
+
+void t_print(void *param)
+{
+    int i;
+    char *str = (char *) param;
+    
+    for (i=0; i<10; i++) {
+         mutex_lock(mutex);
+         display(str);
+         mutex_unlock(mutex);
+    }
+}
+
+
+int main(void)
+{
+    mutex = mutex_create();
+    
+    printf("====== intermixed ======\n");
+    
+    if (thread_init(t_print, (void *) "Hyori Lee\n") < 0)
+        fatal("thread_init() failed: %s", strerror(errno));
+    
+    if (thread_init(t_print, (void *) "Boa Kwon\n") < 0)
+        fatal("thread_init() failed: %s", strerror(errno));
+    
+    thread_wait(1);
+    thread_wait(1);
+    
+    
+    printf("====== not intermixed ======\n");
+    
+    if (thread_init(t_print, (void *) "Hyori Lee\n") < 0)
+        fatal("thread_init() failed: %s", strerror(errno));
+    
+    thread_wait(1);
+    
+    if (thread_init(t_print, (void *) "Boa Kwon\n") < 0)
+        fatal("thread_init() failed: %s", strerror(errno));
+    
+    thread_wait(1);
+    
+    /*
+    printf("====== this next thread should not finish ======\n");
+    
+    if (thread_init(t_print, (void *) "Ayumi Hamasaki\n") < 0)
+        fatal("thread_init() failed: %s", strerror(errno));
+    */
+    return mutex_destroy(mutex);
+    
+}
\ No newline at end of file
diff -Naur origsrc/tools/Makefile src/tools/Makefile
--- origsrc/tools/Makefile	2005-09-08 16:32:44.000000000 +0000
+++ src/tools/Makefile	2009-08-29 19:10:34.000000000 +0000
@@ -20,6 +20,7 @@
 	AT:../drivers/at_wini/at_wini \
 	BIOS:../drivers/bios_wini/bios_wini \
 	FLOPPY:../drivers/floppy/floppy \
+	../servers/ss/ss \
 	../servers/init/init \
 #	bootdev.img
 
diff -Naur origsrc/tools/revision src/tools/revision
--- origsrc/tools/revision	2005-10-18 23:12:31.000000000 +0000
+++ src/tools/revision	2009-08-31 23:58:00.000000000 +0000
@@ -1 +1 @@
-0
+195
