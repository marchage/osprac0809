diff -Naur origsrc/include/minix/callnr.h src/include/minix/callnr.h
--- origsrc/include/minix/callnr.h	2005-08-04 19:23:02.000000000 +0000
+++ src/include/minix/callnr.h	2009-08-28 04:24:11.000000000 +0000
@@ -1,4 +1,4 @@
-#define NCALLS		  91	/* number of system calls allowed */
+#define NCALLS		  93	/* number of system calls allowed */
 
 #define EXIT		   1 
 #define FORK		   2 
@@ -79,3 +79,7 @@
 #define GETPRIORITY       88	/* to PM */
 #define SETPRIORITY       89	/* to PM */
 #define GETTIMEOFDAY      90	/* to PM */
+
+/* Profiling system calls */
+#define PROFILE		  91 /* to PM */
+#define GETPROF		  92 /* to PM */ 
diff -Naur origsrc/include/minix/com.h src/include/minix/com.h
--- origsrc/include/minix/com.h	2005-09-16 14:23:14.000000000 +0000
+++ src/include/minix/com.h	2009-08-28 04:26:32.000000000 +0000
@@ -216,8 +216,10 @@
 #  define SYS_TIMES	 (KERNEL_CALL + 25)	/* sys_times() */
 #  define SYS_GETINFO    (KERNEL_CALL + 26) 	/* sys_getinfo() */
 #  define SYS_ABORT      (KERNEL_CALL + 27)	/* sys_abort() */
+#  define SYS_PROFILE    (KERNEL_CALL + 28)	/* sys_profile() */
+#  define SYS_GETPROF    (KERNEL_CALL + 29)	/* sys_profile() */
 
-#define NR_SYS_CALLS	28	/* number of system calls */ 
+#define NR_SYS_CALLS	30	/* number of system calls */ 
 
 /* Field names for SYS_MEMSET, SYS_SEGCTL. */
 #define MEM_PTR		m2_p1	/* base */
@@ -373,6 +375,13 @@
 #define SEL_ERRORFDS   m8_p3
 #define SEL_TIMEOUT    m8_p4
 
+/* Field names for SYS_PROFILE, _GETPROF. */
+#define PROF_PROC_NR     m1_i1	/* indicates a (child) process */
+#define PROF_START_ADDR  m1_i2	/* process priority */
+#define PROF_END_ADDR    m1_i3	/* indicates a (parent) process */
+#define PROF_RES_DATA    m1_p1	/* indicates a (parent) process */
+
+
 /*===========================================================================*
  *                Messages for system management server 		     *
  *===========================================================================*/
diff -Naur origsrc/include/minix/syslib.h src/include/minix/syslib.h
--- origsrc/include/minix/syslib.h	2005-08-22 15:23:45.000000000 +0000
+++ src/include/minix/syslib.h	2009-08-28 22:40:43.000000000 +0000
@@ -146,5 +146,9 @@
 #define sys_inl(p,v)	sys_in((p), (unsigned long*) (v), DIO_LONG)
 _PROTOTYPE(int sys_in, (int port, unsigned long *value, int type)	);
 
+/* Profile kernel calls stubs. */
+_PROTOTYPE(int sys_profile, (int proc_nr, int start_addr, int end_addr));
+_PROTOTYPE(int sys_getprof, (int prof, void *profdata)              );
+
 #endif /* _SYSLIB_H */
 
diff -Naur origsrc/include/profstub.h src/include/profstub.h
--- origsrc/include/profstub.h	1970-01-01 00:00:00.000000000 +0000
+++ src/include/profstub.h	2009-08-28 02:27:57.000000000 +0000
@@ -0,0 +1,30 @@
+
+#ifndef __PROFSTUB_H
+#define __PROFSTUB_H
+
+#define PROF_BUF_SIZE   1024
+#define STOP_PROF       0  /*pid to indicate a profile stop request*/
+#define MAX_VALUE_LONG  4294967295
+#define VERBOSE         0
+
+/*
+ * This is the data structure used to transfer profiling
+ * information between the user program and the kernel.
+ */
+struct prof_data
+{
+  int start_addr;
+  int end_addr;
+  int bins_used;
+  unsigned long buffer[PROF_BUF_SIZE];
+};
+
+/*
+ * These are the prototypes for the functions used to
+ * invoke the respective system calls.
+ */
+int profile(int pid, int start_addr, int end_addr);
+int getprof(struct prof_data *profdata);
+
+#endif
+
diff -Naur origsrc/lib/other/Makefile src/lib/other/Makefile
--- origsrc/lib/other/Makefile	2005-08-25 11:33:43.000000000 +0000
+++ src/lib/other/Makefile	2009-08-28 04:18:00.000000000 +0000
@@ -52,6 +52,7 @@
 	$(LIBRARY)(nlist.o) \
 	$(LIBRARY)(peekpoke.o) \
 	$(LIBRARY)(popen.o) \
+	$(LIBRARY)(profstub.o) \
 	$(LIBRARY)(putenv.o) \
 	$(LIBRARY)(putw.o) \
 	$(LIBRARY)(random.o) \
@@ -212,6 +213,9 @@
 $(LIBRARY)(popen.o):	popen.c
 	$(CC1) popen.c
 
+$(LIBRARY)(profstub.o):	profstub.c
+	$(CC1) profstub.c
+
 $(LIBRARY)(putenv.o):	putenv.c
 	$(CC1) putenv.c
 
diff -Naur origsrc/lib/other/profstub.c src/lib/other/profstub.c
--- origsrc/lib/other/profstub.c	1970-01-01 00:00:00.000000000 +0000
+++ src/lib/other/profstub.c	2009-08-28 02:27:58.000000000 +0000
@@ -0,0 +1,33 @@
+
+#include "profstub.h"
+#include "lib.h"
+
+/*
+ * This is the implementation for the function to
+ * invoke the PROFILE system call.
+ */
+int profile(int pid, int start_addr, int end_addr)
+{
+  message m;
+
+  m.m1_i1 = pid;
+  m.m1_i2 = start_addr;
+  m.m1_i3 = end_addr;
+
+  return _syscall(MM, PROFILE, &m);
+}
+
+
+/*
+ * This is the implementation for the function to
+ * invoke the GETPROF system call.
+ */
+int getprof(struct prof_data *profdata)
+{
+  message m;
+
+  m.m1_p1 = (void *)profdata;
+
+  return _syscall(MM, GETPROF, &m);
+}
+
diff -Naur origsrc/lib/syslib/Makefile src/lib/syslib/Makefile
--- origsrc/lib/syslib/Makefile	2005-07-29 10:21:04.000000000 +0000
+++ src/lib/syslib/Makefile	2009-08-28 04:15:56.000000000 +0000
@@ -43,6 +43,9 @@
 	$(LIBSYS)(sys_setalarm.o) \
 	$(LIBSYS)(sys_memset.o) \
 	$(LIBSYS)(taskcall.o) \
+	$(LIBSYS)(sys_profile.o) \
+	$(LIBSYS)(sys_getprof.o) \
+
 
 $(LIBSYS):	$(OBJECTS)
 	aal cr $@ *.o
@@ -153,3 +156,8 @@
 $(LIBSYS)(taskcall.o):	taskcall.c
 	$(CC1) taskcall.c
 
+$(LIBSYS)(sys_profile.o):	sys_profile.c
+	$(CC1) sys_profile.c
+
+$(LIBSYS)(sys_getprof.o):	sys_getprof.c
+	$(CC1) sys_getprof.c
diff -Naur origsrc/lib/syslib/sys_getprof.c src/lib/syslib/sys_getprof.c
--- origsrc/lib/syslib/sys_getprof.c	1970-01-01 00:00:00.000000000 +0000
+++ src/lib/syslib/sys_getprof.c	2009-08-28 23:06:12.000000000 +0000
@@ -0,0 +1,15 @@
+#include "syslib.h"
+
+/*============================================================================*
+ *                                sys_getprof                                 *
+ *============================================================================*/
+PUBLIC int sys_getprof(proc_nr, profdata)
+int proc_nr;                   /* */
+void *profdata;
+{
+  message m;
+  
+  m.PROF_PROC_NR = proc_nr;
+  m.PROF_RES_DATA = profdata;
+  return(_taskcall(SYSTASK, SYS_GETPROF, &m));
+}
diff -Naur origsrc/lib/syslib/sys_profile.c src/lib/syslib/sys_profile.c
--- origsrc/lib/syslib/sys_profile.c	1970-01-01 00:00:00.000000000 +0000
+++ src/lib/syslib/sys_profile.c	2009-08-28 23:01:55.000000000 +0000
@@ -0,0 +1,17 @@
+#include "syslib.h"
+
+/*============================================================================*
+ *                               sys_profile                                  *
+ *============================================================================*/
+PUBLIC int sys_profile(proc_nr, start_addr, end_addr)
+int proc_nr;
+int start_addr;
+int end_addr;
+{
+  message m;
+  
+  m.PROF_PROC_NR = proc_nr;
+  m.PROF_START_ADDR = start_addr;
+  m.PROF_END_ADDR = end_addr;
+  return(_taskcall(SYSTASK, SYS_PROFILE, &m));
+}
diff -Naur origsrc/servers/fs/table.c src/servers/fs/table.c
--- origsrc/servers/fs/table.c	2005-08-04 19:23:02.000000000 +0000
+++ src/servers/fs/table.c	2009-08-28 02:27:58.000000000 +0000
@@ -108,6 +108,8 @@
 	no_sys,		/* 88 = getpriority */
 	no_sys,		/* 89 = setpriority */
 	no_sys,		/* 90 = gettimeofday */
+	no_sys,     /* 91 = profile */
+	no_sys,     /* 92 = getprof */
 };
 /* This should not fail with "array size is negative": */
 extern int dummy[sizeof(call_vec) == NCALLS * sizeof(call_vec[0]) ? 1 : -1];
diff -Naur origsrc/servers/pm/Makefile src/servers/pm/Makefile
--- origsrc/servers/pm/Makefile	2005-07-19 13:21:50.000000000 +0000
+++ src/servers/pm/Makefile	2009-08-28 02:27:58.000000000 +0000
@@ -14,7 +14,7 @@
 LDFLAGS = -i
 
 OBJ = 	main.o forkexit.o break.o exec.o time.o timers.o \
-	signal.o alloc.o utility.o table.o trace.o getset.o misc.o
+	signal.o alloc.o utility.o table.o trace.o getset.o misc.o profile.o
 
 # build local binary
 all build:	$(SERVER)
diff -Naur origsrc/servers/pm/param.h src/servers/pm/param.h
--- origsrc/servers/pm/param.h	2005-08-05 12:44:06.000000000 +0000
+++ src/servers/pm/param.h	2009-08-28 23:44:19.000000000 +0000
@@ -57,3 +57,8 @@
 #define tell_fs_arg2    m1_i2
 #define tell_fs_arg3    m1_i3
 
+/* The following names are synonyms for the variables in a profile message. */
+#define prof_pid		m1_i1
+#define prof_begin_addr	m1_i2
+#define prof_end_addr	m1_i3
+#define prof_res_data	m1_p1
diff -Naur origsrc/servers/pm/profile.c src/servers/pm/profile.c
--- origsrc/servers/pm/profile.c	1970-01-01 00:00:00.000000000 +0000
+++ src/servers/pm/profile.c	2009-08-29 00:06:12.000000000 +0000
@@ -0,0 +1,41 @@
+#include "pm.h"
+#include <sys/wait.h>
+#include <minix/callnr.h>
+#include <minix/com.h>
+#include <signal.h>
+#include <profstub.h>
+#include "mproc.h"
+#include "param.h"
+
+
+PUBLIC int do_profile(void)
+{
+	int proc;
+	
+	/* TODO negative values allowed? */
+	if (m_in.prof_pid == STOP_PROF) {
+		proc = STOP_PROF;
+	} else {
+		proc = proc_from_pid(m_in.prof_pid);
+		if (proc == -1)
+			return ESRCH;  /* no process with given pid exists */
+		
+/*		if (((&mproc[proc])->mp_flags & SEPARATE) == SEPARATE) {
+			printf("PM: SEPARATE FLAG SET");
+		} else {
+			printf("PM: SEPARATE FLAG NOT SET");
+		}
+*/	}
+	
+	return sys_profile(proc, m_in.prof_begin_addr, m_in.prof_end_addr);
+} 
+
+
+PUBLIC int do_getprof()
+{
+	/* Does the pointer point to something? */
+	if (!m_in.prof_res_data)
+		return EFAULT;
+	
+	return sys_getprof(who, m_in.prof_res_data);
+}
diff -Naur origsrc/servers/pm/proto.h src/servers/pm/proto.h
--- origsrc/servers/pm/proto.h	2005-08-25 12:05:09.000000000 +0000
+++ src/servers/pm/proto.h	2009-08-29 00:07:15.000000000 +0000
@@ -69,6 +69,10 @@
 
 _PROTOTYPE( void setreply, (int proc_nr, int result)			);
 
+/* profile.c */
+_PROTOTYPE( int do_profile, (void)					);
+_PROTOTYPE( int do_getprof, (void)					);
+
 /* signal.c */
 _PROTOTYPE( int do_alarm, (void)					);
 _PROTOTYPE( int do_kill, (void)						);
@@ -110,4 +114,3 @@
 _PROTOTYPE( int get_mem_map, (int proc_nr, struct mem_map *mem_map)	);
 _PROTOTYPE( char *find_param, (const char *key));
 _PROTOTYPE( int proc_from_pid, (pid_t p));
-
diff -Naur origsrc/servers/pm/table.c src/servers/pm/table.c
--- origsrc/servers/pm/table.c	2005-08-10 09:37:54.000000000 +0000
+++ src/servers/pm/table.c	2009-08-28 02:27:58.000000000 +0000
@@ -107,6 +107,8 @@
 	do_getsetpriority,	/* 88 = getpriority */
 	do_getsetpriority,	/* 89 = setpriority */
 	do_time,	/* 90 = gettimeofday */
+	do_profile, /* 91 = profile */
+	do_getprof, /* 92 = getprof */
 };
 /* This should not fail with "array size is negative": */
 extern int dummy[sizeof(call_vec) == NCALLS * sizeof(call_vec[0]) ? 1 : -1];
diff -Naur origsrc/kernel/clock.c src/kernel/clock.c
--- origsrc/kernel/clock.c	2005-10-09 19:52:27.000000000 +0000
+++ src/kernel/clock.c	2009-08-31 11:40:31.000000000 +0000
@@ -31,6 +31,7 @@
 
 #include "kernel.h"
 #include "proc.h"
+#include "profile.h"
 #include <signal.h>
 #include <minix/com.h>
 
@@ -38,6 +39,7 @@
 FORWARD _PROTOTYPE( void init_clock, (void) );
 FORWARD _PROTOTYPE( int clock_handler, (irq_hook_t *hook) );
 FORWARD _PROTOTYPE( int do_clocktick, (message *m_ptr) );
+FORWARD _PROTOTYPE( void profile_inc, (struct proc *proc) );
 
 /* Clock parameters. */
 #define COUNTER_FREQ (2*TIMER_FREQ) /* counter frequency using square wave */
@@ -138,6 +140,9 @@
   outb(TIMER0, TIMER_COUNT >> 8);	/* load timer high byte */
   put_irq_handler(&clock_hook, CLOCK_IRQ, clock_handler);/* register handler */
   enable_irq(&clock_hook);		/* ready for clock interrupts */
+  
+  prof_is_profiling = 0;  /* initially not profiling */
+  prof_proc_nr = -1;      /* init value */
 }
 
 /*===========================================================================*
@@ -152,6 +157,27 @@
 }
 
 /*===========================================================================*
+ *				profile_inc				     *
+ *===========================================================================*/
+PRIVATE void profile_inc(proc_ptr)
+struct proc *proc_ptr;       /* currently running process */
+{
+  int pc = (int) proc_ptr->p_reg.pc;
+
+  if (pc >= k_prof_data.start_addr && pc <= k_prof_data.end_addr) {
+      int bin_i = (pc - k_prof_data.start_addr) / prof_bin_size;
+
+      /* Increment bin by one. */
+      if (k_prof_data.buffer[bin_i] < MAX_VALUE_LONG) {
+          k_prof_data.buffer[bin_i]++;
+      } else {
+          /* MAX_VALUE_LONG reached for bin_i. */
+          prof_is_profiling = 0;
+      }
+  }
+}
+
+/*===========================================================================*
  *				clock_handler				     *
  *===========================================================================*/
 PRIVATE int clock_handler(hook)
@@ -205,6 +231,10 @@
       bill_ptr->p_ticks_left -= ticks;
   }
 
+  /* Are we profiling? */
+  if (prof_is_profiling && proc_ptr->p_nr == prof_proc_nr)
+      profile_inc(proc_ptr);  /* call profile's clocktick handler */
+
   /* Check if do_clocktick() must be called. Done for alarms and scheduling.
    * Some processes, such as the kernel tasks, cannot be preempted. 
    */ 
diff -Naur origsrc/kernel/config.h src/kernel/config.h
--- origsrc/kernel/config.h	2005-09-11 16:44:06.000000000 +0000
+++ src/kernel/config.h	2009-08-28 02:27:58.000000000 +0000
@@ -42,6 +42,9 @@
 #define USE_PHYSCOPY  	   1 	/* copy using physical addressing */
 #define USE_PHYSVCOPY  	   1	/* vector with physical copy requests */
 #define USE_MEMSET  	   1	/* write char to a given memory area */
+#define USE_PROFILE    	   1	/* profile a process */
+#define USE_GETPROF    	   1	/* get profile result */
+
 
 /* Length of program names stored in the process table. This is only used
  * for the debugging dumps that can be generated with the IS server. The PM
diff -Naur origsrc/kernel/profile.h src/kernel/profile.h
--- origsrc/kernel/profile.h	1970-01-01 00:00:00.000000000 +0000
+++ src/kernel/profile.h	2009-08-31 12:02:38.000000000 +0000
@@ -0,0 +1,12 @@
+#ifndef PROFILE_H
+#define PROFILE_H
+
+#include <profstub.h>
+
+/* Profile related variables. */
+EXTERN int prof_is_profiling;           /* profiling state */
+EXTERN int prof_proc_nr;                /* p_nr of process */
+EXTERN struct prof_data k_prof_data;    /* kernel result buffer */
+EXTERN int prof_bin_size;
+
+#endif /* PROFILE_H */
diff -Naur origsrc/kernel/system/Makefile src/kernel/system/Makefile
--- origsrc/kernel/system/Makefile	2005-07-29 15:26:23.000000000 +0000
+++ src/kernel/system/Makefile	2009-08-28 02:27:58.000000000 +0000
@@ -44,6 +44,8 @@
 	$(SYSTEM)(do_sigreturn.o) \
 	$(SYSTEM)(do_abort.o) \
 	$(SYSTEM)(do_getinfo.o) \
+	$(SYSTEM)(do_profile.o) \
+	$(SYSTEM)(do_getprof.o) \
 
 $(SYSTEM):	$(OBJECTS)
 	aal cr $@ *.o
@@ -138,3 +140,9 @@
 
 $(SYSTEM)(do_segctl.o):	do_segctl.c
 	$(CC) do_segctl.c
+	
+$(SYSTEM)(do_profile.o):	do_profile.c
+	$(CC) do_profile.c
+	
+$(SYSTEM)(do_getprof.o):	do_getprof.c
+	$(CC) do_getprof.c
diff -Naur origsrc/kernel/system/do_exit.c src/kernel/system/do_exit.c
--- origsrc/kernel/system/do_exit.c	2005-10-14 08:50:02.000000000 +0000
+++ src/kernel/system/do_exit.c	2009-08-31 12:03:32.000000000 +0000
@@ -6,6 +6,7 @@
  */
 
 #include "../system.h"
+#include "../profile.h"
 
 #if USE_EXIT
 
@@ -76,6 +77,10 @@
       }
   }
 
+  /* If this process was being profiled then profile needs to stop. */
+  if (prof_is_profiling && prof_proc_nr == rc->p_nr)
+      prof_is_profiling = 0;
+
   /* Check the table with IRQ hooks to see if hooks should be released. */
   for (i=0; i < NR_IRQ_HOOKS; i++) {
       if (irq_hooks[i].proc_nr == proc_nr(rc)) {
diff -Naur origsrc/kernel/system/do_getprof.c src/kernel/system/do_getprof.c
--- origsrc/kernel/system/do_getprof.c	1970-01-01 00:00:00.000000000 +0000
+++ src/kernel/system/do_getprof.c	2009-08-31 11:15:14.000000000 +0000
@@ -0,0 +1,43 @@
+#include "../system.h"
+#include <signal.h>
+#include "../proc.h"
+#include "../profile.h"
+#if (CHIP == INTEL)
+#include "../protect.h"
+#endif
+
+#if USE_GETPROF
+
+/*============================================================================*
+ *                               do_getprof                                   *
+ *============================================================================*/
+PUBLIC int do_getprof(m)
+message *m;	/* pointer to request message */
+{
+	phys_bytes u_phys_bytes, k_phys_bytes;
+	
+	/* Only return if there's something to return (set after first run). */
+	if (prof_proc_nr == -1) {
+		return EFAULT;
+	}
+	
+	lock(0, "do_getprof");
+	
+	/* Get physical address of user space profile data and k_prof_data. */
+	u_phys_bytes = numap_local(m->PROF_PROC_NR,
+			(vir_bytes) m->PROF_RES_DATA, sizeof(k_prof_data));
+	k_phys_bytes = vir2phys(&k_prof_data);
+	
+	if (!u_phys_bytes || !k_phys_bytes) {
+		return EFAULT;
+	}
+	
+	/* Copy k_prof_data to user space. */
+	phys_copy(k_phys_bytes, u_phys_bytes, (phys_bytes) sizeof(k_prof_data));
+	
+	unlock(0);
+	
+	return OK;
+}
+
+#endif /* USE_GETPROF */
diff -Naur origsrc/kernel/system/do_profile.c src/kernel/system/do_profile.c
--- origsrc/kernel/system/do_profile.c	1970-01-01 00:00:00.000000000 +0000
+++ src/kernel/system/do_profile.c	2009-08-31 12:38:55.000000000 +0000
@@ -0,0 +1,79 @@
+#include "../system.h"
+#include "../profile.h"
+
+#if USE_PROFILE
+
+/*============================================================================*
+ *                                do_profile                                  *
+ *============================================================================*/
+PUBLIC int do_profile(m)
+message *m;
+{
+	int i;
+	int mem_size;
+	struct proc *proc;
+	
+	if (m->PROF_PROC_NR == STOP_PROF) {
+		prof_is_profiling = 0;
+		return OK;
+	}
+	
+	if (!isokprocn(m->PROF_PROC_NR))
+		return ESRCH;  /* no process with given pid exists */
+	
+	if (prof_is_profiling == 1)
+		return EBUSY;  /* already profiling something else */
+	
+	/* Disable interrupts. */
+	lock(6, "do_profile");
+	
+	proc = proc_addr(m->PROF_PROC_NR);
+	prof_proc_nr = proc->p_nr;
+	
+	/* Initialize end_addr to the program's end address.  (Later, we will
+	 * compare the user's requested end address with this.) */
+	if (proc->p_memmap[T].mem_len == 0) {  /* common I&D */
+		if (VERBOSE) kprintf("KERNEL: combined I&D\n");
+		k_prof_data.end_addr = proc->p_memmap[D].mem_len * CLICK_SIZE - 1;
+	} else { /* separate I&D */
+		if (VERBOSE) kprintf("KERNEL: separate I&D\n");
+		k_prof_data.end_addr = proc->p_memmap[T].mem_len * CLICK_SIZE - 1;
+	}
+	
+	/* Validate user's requested start and end address. */
+	if (m->PROF_START_ADDR < 0 || m->PROF_START_ADDR > m->PROF_END_ADDR ||
+			m->PROF_END_ADDR > k_prof_data.end_addr) {
+		return EFAULT;
+	} else {
+		k_prof_data.start_addr = m->PROF_START_ADDR;
+		if (m->PROF_END_ADDR > 0) {
+			k_prof_data.end_addr = m->PROF_END_ADDR;
+		}
+	}
+	
+	/* Set prof_bin_size. */
+	mem_size = k_prof_data.end_addr - k_prof_data.start_addr + 1;
+	prof_bin_size = mem_size / PROF_BUF_SIZE;
+	if (mem_size % PROF_BUF_SIZE != 0)
+		prof_bin_size += 1;
+	
+	/* Set k_prof_data.bins_used. */
+	k_prof_data.bins_used = mem_size / prof_bin_size;
+	if (mem_size % k_prof_data.bins_used != 0)
+		k_prof_data.bins_used += 1;
+	
+	/* Clear all bins in the buffer to zero. */
+	for (i=0; i<PROF_BUF_SIZE; i++) {
+		k_prof_data.buffer[i] = 0;
+	}
+	
+	/* Reenable interrupts. */
+	unlock(6);
+	
+	/* Start profiling. */
+	prof_is_profiling = 1;
+	
+	return OK;
+}
+
+#endif /* USE_PROFILE */
diff -Naur origsrc/kernel/system.c src/kernel/system.c
--- origsrc/kernel/system.c	2005-10-14 14:45:49.000000000 +0000
+++ src/kernel/system.c	2009-08-28 02:27:58.000000000 +0000
@@ -167,6 +167,10 @@
   /* System control. */
   map(SYS_ABORT, do_abort);		/* abort MINIX */
   map(SYS_GETINFO, do_getinfo); 	/* request system information */ 
+  
+  /* Process profiling. */
+  map(SYS_PROFILE, do_profile); 		/* profile a process */
+  map(SYS_GETPROF, do_getprof);		/* get profile data */
 }
 
 /*===========================================================================*
diff -Naur origsrc/kernel/system.h src/kernel/system.h
--- origsrc/kernel/system.h	2005-10-14 09:14:49.000000000 +0000
+++ src/kernel/system.h	2009-08-28 02:27:58.000000000 +0000
@@ -169,5 +169,15 @@
 #define do_setalarm do_unused
 #endif
 
+_PROTOTYPE( int do_profile, (message *m_ptr) );
+#if ! USE_PROFILE
+#define do_profile do_unused
+#endif
+
+_PROTOTYPE( int do_getprof, (message *m_ptr) );
+#if ! USE_GETPROF
+#define do_getprof do_unused
+#endif
+
 #endif	/* SYSTEM_H */
 
diff -Naur origsrc/kernel/table.c src/kernel/table.c
--- origsrc/kernel/table.c	2005-10-02 19:00:17.000000000 +0000
+++ src/kernel/table.c	2009-08-31 12:04:44.000000000 +0000
@@ -31,6 +31,7 @@
 #include "kernel.h"
 #include "proc.h"
 #include "ipc.h"
+#include "profile.h"
 #include <minix/com.h>
 #include <ibm/int86.h>
 
diff -Naur origsrc/extra/Makefile src/extra/Makefile
--- origsrc/extra/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ src/extra/Makefile	2009-08-31 18:47:23.000000000 +0000
@@ -0,0 +1,31 @@
+# Practical Operating Systems 2008/2009, assignment 1
+# Makefile
+#
+# Richard van Heuven van Staereling  <richard@few.vu.nl>
+# Marc Hage                          <mrhage@few.vu.nl>
+#
+
+# flags, programs
+DEBUG	= 0
+
+MAKE	= exec make
+CC	= cc
+CFLAGS	= -g -Wall -DDEBUG=$(DEBUG)
+LDFLAGS	=
+RM	= rm -f
+
+PROGS	= profile
+
+
+# targets
+all: $(PROGS)
+build: $(PROGS)
+
+profile: profile.o
+	$(CC) $(CFLAGS) -o $@ $<
+
+profile.o: profile.c profile.h
+	$(CC) $(CFLAGS) -o $@ -c $<
+
+clean:
+	$(RM) $(PROGS) core *~ *.o
diff -Naur origsrc/extra/profile.c src/extra/profile.c
--- origsrc/extra/profile.c	1970-01-01 00:00:00.000000000 +0000
+++ src/extra/profile.c	2009-08-31 18:23:38.000000000 +0000
@@ -0,0 +1,406 @@
+/* Practical Operating Systems 2008/2009, assignment 1
+ * profile.c -- user-space frontend for profile
+ *
+ * Richard van Heuven van Staereling  <richard@few.vu.nl>
+ * Marc Hage                          <mrhage@few.vu.nl>
+ *
+ */
+
+#include "profile.h"
+
+
+char **program_args;
+int start_addr;
+int end_addr;
+int num_bars_to_print;  
+struct prof_data gp_prof_data;  /* filled by getprof syscall */
+pid_t child;                    /* pid to profile */
+int cstatus;                    /* Exit status of child. */ 
+
+
+
+/*============================================================================*
+ *                                  fatal                                     *
+ *============================================================================*/
+PRIVATE void fatal(const char *description, ...)
+/* Exits the program with 1 and prints a one-line description to stdout.
+ * Description is assumed to be one line, without the trailing '\n'. */
+{
+	va_list args;
+	
+	va_start(args, description);
+	vfprintf(stdout, description, args);
+	va_end(args);
+	fprintf(stdout, "\n");
+	
+	exit(EXIT_FAILURE);
+}
+
+
+
+
+/*============================================================================*
+ *                                   sigint                                   *
+ *============================================================================*/
+void sigint(int sig)
+/* Used by parent to stop profiling by kernel. */
+{
+	DPRINTF("PROFILE: getpid() = %d\n", getpid());
+	
+	if (child) { /* not needed, only parents signal handler is overwritten */
+		/* parent process */
+		kill(child, SIGKILL);
+		
+		/* stop profiling should not be nessesarry, do_exit should stop profiling*/ 
+		if (profile(STOP_PROF, 0, 0))
+			fatal("Could not stop profiling: %s", strerror(errno));
+	}
+	
+	/*free(program_args);
+	exit(EXIT_SUCCESS);*/
+	(void) signal(SIGINT, SIG_DFL); /* let the results print out in parent */
+}
+
+
+
+
+/* round double to int */
+int round(double d) {
+	int i;
+	double temp = d - floor(d);
+	if (temp >= (double) 0.5)
+		i = ceil(d);
+	else
+		i = floor(d);
+	return i;
+}
+
+
+
+
+
+/*============================================================================*
+ *                            print_prof_results                              *
+ *============================================================================*/
+void print_prof_results(void)
+/* print 1st, 2nd, and 3rd (+) lines */
+{
+	int r, i, j;
+	int mem_size, binsPerBar, binsLastBar, bin_size;
+	int maxPerc = 0, numBarsToPrint;
+	/*numBarsToPrint is value used evantually and num_bars_to_print is only the requested bars to print */
+	/* stores maximum value found in any bin,  */
+	unsigned long bins_max;
+	/* stores bin values in stars per bin: */
+	double binFractionBuffer[PROF_BUF_SIZE];
+	/* stores aggregate bin values in stars per bar 
+	 * doubles so rounding only has to be done once: on printing */
+	double barStarBuffer[PROF_BUF_SIZE];
+	double totalNumBarStars = 0.0, maxPercBars = 0.0, maxBarsStars = 0.0;
+	
+	/* num of bars to output, first check of numbars to print
+	 * further check e.g. in the case of 7 bins and 6 bars to print, 
+	 * will be handled later on */    
+	if (num_bars_to_print < 1 || num_bars_to_print > gp_prof_data.bins_used)
+		num_bars_to_print = gp_prof_data.bins_used;
+	
+	/* including end address */
+	mem_size = (gp_prof_data.end_addr - gp_prof_data.start_addr) + 1;
+	/* number of bins aggregated per line, round up */
+	binsPerBar = ceil((double)gp_prof_data.bins_used/(double)num_bars_to_print);
+	/* may display the sum of fewer bins than the rest of the bars */
+	binsLastBar = gp_prof_data.bins_used % binsPerBar;
+	/* if no rest... */
+	if (!binsLastBar) {
+		/* ...last is equal to other bars */
+		binsLastBar = binsPerBar;
+	}
+	
+	/* adjust the final number of bars to print based on calc of binsPerBar */
+	numBarsToPrint = ceil((double)gp_prof_data.bins_used/(double)binsPerBar);
+	
+	bin_size = mem_size / PROF_BUF_SIZE;
+	if (mem_size % PROF_BUF_SIZE != 0) {
+		bin_size += 1;
+	}
+	
+	DPRINTF("PROFILE: gp_prof_data.start_addr = %04X\n",gp_prof_data.start_addr);
+	DPRINTF("PROFILE: gp_prof_data.end_addr   = %04X\n",gp_prof_data.end_addr);
+	DPRINTF("PROFILE: gp_prof_data.bins_used  = %d\n",gp_prof_data.bins_used);
+	DPRINTF("PROFILE: mem_size  = %d\n",mem_size);
+	DPRINTF("PROFILE: binsPerBar  = %d\n",binsPerBar);
+	DPRINTF("PROFILE: binsLastBar  = %d\n",binsLastBar);
+	DPRINTF("PROFILE: numBarsToPrint  = %d\n",numBarsToPrint);
+	DPRINTF("PROFILE: bin_size  = %d\n",bin_size);
+	
+	/* Find the maximal value in the bins. */
+	bins_max = 0;
+	for (i = 0; i < gp_prof_data.bins_used; i++) {
+		if (gp_prof_data.buffer[i] > bins_max) {
+			bins_max = gp_prof_data.buffer[i];
+		}
+	}
+	
+	/* CONVERT: unsigned long buffer to star buffer.
+	 * Since buffer[i] can contain a large value which prohibits calculations
+	 * with it. So compensate for near to MAX_VALUE_LONG values in buffer[i]
+	 * as to prevent unsigned long overflows, by converting bin values to 
+	 * star values. */
+	for (i = 0; i < gp_prof_data.bins_used; i++) {
+		if (bins_max) {
+			/* eventually cast back to double: since the values are now a 
+			 * fraction of the largest, and thus smaller than 1, doing aritmatic
+			 * on them is now overflow safe */
+			binFractionBuffer[i] = (double) ((long double) gp_prof_data.buffer[i] / (long double) bins_max);
+		} else {
+			/* no bins contain a value other than 0 */
+			binFractionBuffer[i] = 0.0;
+		}
+	}
+	
+	/* for every bar: */
+	for (j = 1; j <= numBarsToPrint; j++) {
+		double loopTotal = 0.0; /* reset loop total */
+		int barRangeEnd, barRangeStart = (j-1) * binsPerBar;
+		if (j < numBarsToPrint) {/* end addr for all bars except the last... */
+			barRangeEnd = j * binsPerBar - 1;
+		} else { /*...which should be shorter */
+			barRangeEnd = gp_prof_data.bins_used - 1;
+		}
+		/* CONVERT: bin_fractions to bar_fractions */
+		for (i = barRangeStart; i <= barRangeEnd; i++) {
+			loopTotal += binFractionBuffer[i];
+		}
+		barStarBuffer[j-1] = loopTotal;
+		/* FIND: largest bar */
+		if (barStarBuffer[j-1] > maxBarsStars) {
+			maxBarsStars = barStarBuffer[j-1];
+		}
+		/* keep track of total nr */
+		totalNumBarStars += barStarBuffer[j-1];
+	}
+	
+	/* total number of stars in all bars, converted to stars after determining 
+	* maximum in bars buffer.
+	* needed to calculate persentages of stars in a bar (aka line) */
+	if (maxBarsStars)
+		totalNumBarStars = totalNumBarStars * NUM_STARS / maxBarsStars;
+	
+	if (totalNumBarStars) {
+		/* for every bar: */
+		for (j = 0; j < numBarsToPrint; j++) {
+			int mxPTmp = 0;
+			/* CONVERT: bar containing aggregate fractions to bar containing stars 
+			* Must be done in separate step from previous for(), because
+			* maximum value in bar had to be determined and was not known.
+			*/
+			barStarBuffer[j] = barStarBuffer[j] * (double) NUM_STARS / maxBarsStars;
+			/* find maximum percentage in bar, after a bar has been converted 
+			* to represent star values */
+			mxPTmp = floor(100.0 * barStarBuffer[j] / totalNumBarStars);
+			if (maxPerc < mxPTmp)
+				maxPerc = mxPTmp;
+		}
+	}
+	
+	/* Print first and second line, program name and percentage range. */
+	printf("%s\n", program_args[0]);
+	printf("                  ");
+	printf("0%%........................................................");
+	printf("%s%s", (maxPerc < 10) ? "." : "", (maxPerc < 100) ? "." : "");
+	printf("%d%%\n", maxPerc);
+	
+	/* Print histogram. */
+	for (j = 1; j <= numBarsToPrint; j++) {
+		int barRangeStart, barRangeEnd;
+		double barPerc = 0.0;
+		if (totalNumBarStars) {
+			barPerc = floor(100.0 * barStarBuffer[j-1] / totalNumBarStars);
+		}
+		
+		/* Print address. */
+		barRangeStart = gp_prof_data.start_addr + (j-1) * bin_size * binsPerBar;
+		barRangeEnd = gp_prof_data.start_addr + j * bin_size * binsPerBar - 1;
+		if (j == numBarsToPrint) {  /* last bar, use end address */
+			barRangeEnd = gp_prof_data.end_addr;
+		}
+		printf("%04X-%04X ", barRangeStart, barRangeEnd);
+		
+		/* Print percentage. */
+		if (barPerc > 99.0) { 
+			printf("(%03.0f%%): ", barPerc);
+		} else {
+			printf("(%02.0f%%) : ", barPerc);
+		}
+		
+		/* Print stars and newline. */
+		if (barStarBuffer[j-1]) {
+			for (i = 0; i < round(barStarBuffer[j-1]); i++) {
+				printf("*");
+			}
+		}
+		printf("\n");
+	}
+	return;
+}
+
+
+
+
+/*============================================================================*
+ *                                run_program                                 *
+ *============================================================================*/
+void run_program(char *argv[])
+{
+	/* Halt child process here to synchronize with parent: allows
+	 * profile of small programs. */
+	ptrace(T_OK, 0, 0, 0);
+	
+	if (execvp(argv[0], argv) < 0) 
+		fatal("child failed execvp(): %s", strerror(errno));
+}
+
+
+
+
+/*============================================================================*
+ *                                run_profile                                 *
+ *============================================================================*/
+void run_profile(pid_t pid)
+{
+	int cstatus;  /* exit status of child */ 
+	pid_t c;      /* pid of child to be returned by wait */ 
+	
+	/* Parent signal handler: to kill child and stop profiling. */
+	(void) signal(SIGINT, sigint);
+	
+	/* Wait for child to halt. */
+	c = wait(&cstatus);
+	if (!WIFSTOPPED(cstatus))
+		fatal("Parent: child did not wait for profiling to start");
+	
+	/* do_profile syscall */
+	if (profile(child, start_addr, end_addr))
+		fatal("Parent: do_profile() syscall failed: %s", strerror(errno));
+	
+	/* Resume child */
+	if (ptrace(T_RESUME, child, 0, 0)) {
+		fprintf(stdout, "Parent: child failed to resume its execution: %s\n", strerror(errno));
+		/* TODO stop profile, combine with signal fucntion? */
+		profile(STOP_PROF,0,0);
+		exit(EXIT_FAILURE);
+	}
+	
+	/* Wait for child to exit. */
+	c = wait(&cstatus);
+	
+	/* Get the profiling data and print it. */
+	if (getprof(&gp_prof_data))
+		/* TODO stop profile, combine with signal fucntion? NOPE already stopped if we reach this point */
+		fatal("Parent: unable to retrieve profiling data");
+}
+
+
+
+
+/*============================================================================*
+ *                                parse_args                                  *
+ *============================================================================*/
+void parse_n_flag(char *arg)
+{
+	num_bars_to_print = atoi(arg);
+	if (!num_bars_to_print)
+		fatal("Suplied number of bars to print is not correct");
+}
+
+
+int is_hex(char *str)
+{
+	static char tmp[64];
+	return (strtok(strcpy(tmp, str), "0123456789ABCDEFabcdef") == NULL);
+}
+
+
+void parse_r_flag(char *arg)
+{
+	char *start_hexaddr, *end_hexaddr;
+	
+	if (strncmp(arg, "-", 1) == 0)
+		fatal("Address range cannot not start with '-'");
+	
+	/* Argument consists of hexadecimals? */
+	start_hexaddr = strtok(arg, "-");
+	end_hexaddr = strtok(NULL, "");
+	if (!is_hex(start_hexaddr) || !is_hex(end_hexaddr))
+		fatal("Suplied address contains non-hexadecimal characters");
+	
+	/* Convert hex string into usable values and check their value. */
+	sscanf(start_hexaddr, "%X", &start_addr);
+	sscanf(end_hexaddr, "%X", &end_addr);
+	if (start_addr < 0 || end_addr < 0 || start_addr > end_addr || 
+			strtok(NULL, ""))
+		fatal("Suplied start and/or end address are not valid");
+}
+
+
+void parse_args(int argc, char *argv[])
+/* Parse arguments and set global variables.  If there is an error, fatal() is
+ * called, an error message is printed to stdout and the program exits. */
+{
+	int n_flag_set = 0, r_flag_set = 0, program_set = 0;
+	
+	/* Skip first argument (usually "./profile"). */
+	argc--; *argv++;
+	
+	while (argc--) {
+		if (strncmp(*argv, "-n", 3) == 0 && !n_flag_set) {
+			*argv++; argc--;
+			parse_n_flag(*argv++);  /* fill num_bars_to_print */
+			n_flag_set = 1;
+		}
+		else if (strncmp(*argv, "-r", 3) == 0 && !r_flag_set) {
+			*argv++; argc--;
+			parse_r_flag(*argv++);  /* fill start_addr, end_addr */
+			r_flag_set = 1;
+		}
+		else {
+			program_args = argv;
+			program_set = 1;
+			break;  /* the program interprets the rest of argv */
+		}
+	}
+	
+	if (!program_set)
+		fatal("Usage: ./profile [-n bars] [-r start_addr-end_addr] \
+program [args...]", argv[0]);
+}
+
+
+
+
+/*============================================================================*
+ *                                   main                                     *
+ *============================================================================*/
+int main(int argc, char* argv[])
+{
+	/* Initialize the global variables. */
+	start_addr = end_addr = 0;
+	parse_args(argc, argv);
+	
+	/* Fork and execute. */
+	child = fork();
+	if (child < (pid_t) 0) 
+		fatal("Failed to fork(): %s", strerror(errno));
+	
+	if (child == 0) {
+		DPRINTF("getpid() CHILD = %d\n", getpid());
+		run_program(program_args);
+	} else {
+		DPRINTF("getpid() PARENT = %d\n", getpid());
+		run_profile(child);
+		print_prof_results();
+	}
+	
+	return EXIT_SUCCESS;
+}
+
diff -Naur origsrc/extra/profile.h src/extra/profile.h
--- origsrc/extra/profile.h	1970-01-01 00:00:00.000000000 +0000
+++ src/extra/profile.h	2009-08-28 22:52:14.000000000 +0000
@@ -0,0 +1,63 @@
+/* Practical Operating Systems 2008/2009, assignment 1
+ * profile.h -- header file for profile.c
+ *
+ * Richard van Heuven van Staereling  <richard@few.vu.nl>
+ * Marc Hage                          <mrhage@few.vu.nl>
+ *
+ */
+
+#ifndef PROFILE_H
+#define PROFILE_H
+
+#define _POSIX_SOURCE  1  /* tell headers to include POSIX stuff */
+
+#include <stdio.h>
+#include <errno.h>
+#include <math.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <signal.h>
+#include <profstub.h>
+#include <unistd.h> 
+#include <sys/ptrace.h>
+#include <stdarg.h>
+
+
+
+
+/*============================================================================*
+ *                               constants                                    *
+ *============================================================================*/
+#define OK              0
+#define NUM_STARS       62
+
+/*
+#define MAX_ARG_LEN     128
+#define MAX_ARGS_CHILD  32
+*/
+
+
+
+/*============================================================================*
+ *                           macro functions                                  *
+ *============================================================================*/
+#define PUBLIC
+#define PRIVATE            static
+
+#if DEBUG == 1
+#define DPRINTF            printf("[DEBUG] "); printf
+#else
+#define DPRINTF            (void)
+#endif
+
+
+
+
+/*============================================================================*
+ *                                prototypes                                  *
+ *============================================================================*/
+_PROTOTYPE(int main, (int argc, char *argv[]));
+
+#endif /* PROFILE_H */
diff -Naur origsrc/tools/revision src/tools/revision
--- origsrc/tools/revision	2005-10-18 23:12:31.000000000 +0000
+++ src/tools/revision	2009-08-31 18:39:43.000000000 +0000
@@ -1 +1 @@
-0
+99
